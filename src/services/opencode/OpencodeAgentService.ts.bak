import * as vscode from 'vscode';import * as path from 'node:path';import * as os from 'node:os';import * as fs from 'node:fs/promises';import { spawn } from 'node:child_process';import { createDecorator } from '../../di/instantiation';import { ILogService } from '../logService';import { IConfigurationService } from '../configurationService';import { IWorkspaceService } from '../workspaceService';import { IWebViewService } from '../webViewService';import { ITransport } from '../claude/transport';import { IOpencodeClientService, type OpencodeEvent } from './OpencodeClientService';import type {  WebViewToExtensionMessage,  RequestMessage,  ResponseMessage,  ErrorResponse,  InitResponse,  GetClaudeStateResponse,  GetClaudeConfigResponse,  SaveClaudeConfigResponse,  GetCurrentSelectionResponse,  GetMcpServersResponse,  GetAssetUrisResponse,  ListSessionsResponse,  GetSessionResponse,  GetAgentsResponse,  ToggleAgentResponse,  DeleteAgentResponse,  GetSkillsResponse,  ToggleSkillResponse,  DeleteSkillResponse,  SetModelResponse,  SetVariantResponse,  SetPermissionModeResponse,  SetThinkingLevelResponse,  GetProgressResponse,  ListFilesResponse,  ShowNotificationRequest,  ShowNotificationResponse,  OpenContentResponse,  OpenDiffResponse,  ExecResponse,  OpenConfigFileResponse,  OpenClaudeInTerminalResponse,  NewConversationTabResponse,  RenameTabResponse,  ToolPermissionResponse} from '../../shared/messages';const OH_MY_HOOKS: Array<{ id: string; description: string }> = [  { id: 'todo-continuation-enforcer', description: 'Ensures tasks are completed' },  { id: 'context-window-monitor', description: 'Monitors context window usage' },  { id: 'session-recovery', description: 'Automatic session recovery' },  { id: 'session-notification', description: 'Session event notifications' },  { id: 'comment-checker', description: 'Code comment validation' },  { id: 'grep-output-truncator', description: 'Truncates large grep outputs' },  { id: 'tool-output-truncator', description: 'Manages tool output sizes' },  { id: 'directory-agents-injector', description: 'Injects directory-specific agents' },  { id: 'directory-readme-injector', description: 'Adds README context' },  { id: 'empty-task-response-detector', description: 'Detects empty responses' },  { id: 'think-mode', description: 'Enables thinking mode' },  { id: 'anthropic-context-window-limit-recovery', description: 'Handles Anthropic limits' },  { id: 'rules-injector', description: 'Injects custom rules' },  { id: 'background-notification', description: 'Background notifications' },  { id: 'auto-update-checker', description: 'Checks for updates' },  { id: 'startup-toast', description: 'Startup notifications' },  { id: 'keyword-detector', description: 'Keyword detection' },  { id: 'agent-usage-reminder', description: 'Agent usage reminders' },  { id: 'non-interactive-env', description: 'Non-interactive environment handling' },  { id: 'interactive-bash-session', description: 'Interactive session management' },  { id: 'empty-message-sanitizer', description: 'Cleans empty messages' },  { id: 'compaction-context-injector', description: 'Context compaction' },  { id: 'thinking-block-validator', description: 'Validates thinking blocks' },  { id: 'claude-code-hooks', description: 'Claude-specific hooks' },  { id: 'ralph-loop', description: 'Ralph agent loop' },  { id: 'preemptive-compaction', description: 'Preemptive compaction' }];type OpenCodeMessageInfo = {  id: string;  sessionID: string;  role: 'user' | 'assistant';  title?: string;  time?: { created: number; updated?: number; completed?: number };  error?: unknown;  tokens?: unknown;  cost?: unknown;};type OpenCodeTextPart = {  id: string;  sessionID: string;  messageID: string;  type: 'text';  text: string;};type OpenCodeReasoningPart = {  id: string;  sessionID: string;  messageID: string;  type: 'reasoning';  text: string;};type OpenCodeToolPart = {  id: string;  sessionID: string;  messageID: string;  type: 'tool';  callID: string;  tool: string;  state: {    status: 'pending' | 'running' | 'completed' | 'error';    input: Record<string, unknown>;    raw?: string;    output?: string;    error?: string;    title?: string;    metadata?: Record<string, unknown>;  };};type OpenCodePatchPart = {  id: string;  sessionID: string;  messageID: string;  type: 'patch';  hash: string;  files: string[];};type OpenCodePermission = {  id: string;  type: string;  pattern?: string | string[];  sessionID: string;  messageID: string;  callID?: string;  title: string;  metadata: Record<string, unknown>;  time?: { created: number };};type ChannelState = {  channelId: string;  cwd: string;  sessionId: string;  modelSetting?: string;  variant?: string;  permissionMode?: string;  workMode?: string;  thinkingLevel?: string;  running: boolean;  sseAbort: AbortController;  assistantMessageIds: Set<string>;  textParts: Map<string, { messageID: string; text: string }>;  pendingTextParts: Map<string, { messageID: string; text: string }>;  reasoningParts: Map<string, { messageID: string; text: string }>;  sentToolUseIds: Set<string>;  toolOutputByToolUseId: Map<string, string>;  tempFiles: Set<string>;  lastRevert?: { messageID: string; partID?: string };  pendingUsage?: {    messageId?: string;    usage?: Record<string, unknown>;  };  lastUsageMessageId?: string;  lastUsageSignature?: string;  needsRefreshAfterIdle?: boolean;  suppressNextIdleResult?: boolean;  abortIdleWaiter?: { resolve: () => void; reject: (error: Error) => void };  lastAutoRefreshAt?: number;};export const IOpencodeAgentService = createDecorator<IOpencodeAgentService>('opencodeAgentService');export interface IOpencodeAgentService {  readonly _serviceBrand: undefined;  setTransport(transport: ITransport): void;  start(): void;  fromClient(message: WebViewToExtensionMessage): Promise<void>;  revertLastChange(): Promise<boolean>;  openOhMyConfig(): Promise<void>;}export class OpencodeAgentService implements IOpencodeAgentService {  readonly _serviceBrand: undefined;  private transport?: ITransport;  private lastActiveChannelId?: string;  private readonly channels = new Map<string, ChannelState>();  private readonly requestWaiters = new Map<    string,    { resolve: (value: unknown) => void; reject: (error: Error) => void }  >();  private readonly resolvedPrimaryAgentsByCwd = new Map<    string,    { plan?: string; build?: string }  >();  constructor(    @ILogService private readonly logService: ILogService,    @IConfigurationService private readonly configService: IConfigurationService,    @IWorkspaceService private readonly workspaceService: IWorkspaceService,    @IWebViewService private readonly webViewService: IWebViewService,    @IOpencodeClientService private readonly client: IOpencodeClientService  ) {}  setTransport(transport: ITransport): void {    this.transport = transport;  }  start(): void {    // no-op (SSE loops are started per-channel on launch)  }  async fromClient(message: WebViewToExtensionMessage): Promise<void> {    switch (message.type) {      case 'launch_claude':        await this.launchChannel(message.channelId, {          resume: message.resume ?? null,          cwd: message.cwd ?? undefined,          initialMessage: message.initialMessage,          model: (message as any).model ?? undefined,          variant: (message as any).variant ?? undefined,          permissionMode: (message as any).permissionMode ?? undefined,          workMode: (message as any).workMode ?? undefined,          thinkingLevel: (message as any).thinkingLevel ?? undefined,          resumeSessionAt: (message as any).resumeSessionAt ?? undefined        });        return;      case 'io_message':        await this.onIoMessage(message.channelId, message.message);        return;      case 'interrupt_claude':        await this.interrupt(message.channelId);        return;      case 'close_channel':        this.closeChannel(message.channelId);        return;      case 'request':        await this.handleRequestMessage(message as RequestMessage);        return;      case 'response':        this.handleResponseMessage(message as ResponseMessage);        return;      case 'cancel_request':        return;      default:        this.logService.warn(`[OpencodeAgentService] Unhandled message: ${(message as any).type}`);    }  }  async revertLastChange(): Promise<boolean> {    const channelId = this.lastActiveChannelId;    const state = channelId ? this.channels.get(channelId) : undefined;    if (!state?.lastRevert) {      vscode.window.showWarningMessage('娌℃湁鍙洖婊氱殑鏈€杩戞敼鍔紙杩樻病鏈変骇鐢熷彲鍥炴粴鐨?patch锛?);      return false;    }    try {      await this.client.revert(        state.sessionId,        { messageID: state.lastRevert.messageID, partID: state.lastRevert.partID },        state.cwd      );      vscode.window.showInformationMessage('宸插洖婊氭渶杩戞敼鍔?);      return true;    } catch (error) {      const msg = error instanceof Error ? error.message : String(error);      vscode.window.showErrorMessage(`鍥炴粴澶辫触: ${msg}`);      return false;    }  }  async openOhMyConfig(): Promise<void> {    const cwd = this.workspaceService.getDefaultWorkspaceFolder()?.uri.fsPath ?? process.cwd();    const configDir = (      this.configService.getValue<string>('opencodeGui.configDir', '') ?? ''    ).trim();    const projectPath = path.join(cwd, '.opencode', 'oh-my-opencode.json');    const userPaths = [      configDir ? path.join(configDir, 'oh-my-opencode.json') : undefined,      configDir ? path.join(configDir, 'opencode', 'oh-my-opencode.json') : undefined,      path.join(os.homedir(), '.config', 'opencode', 'oh-my-opencode.json')    ].filter(Boolean) as string[];    const target = await this.pickExistingPath([projectPath, ...userPaths]);    if (!target) {      vscode.window.showWarningMessage(        '鏈壘鍒?oh-my-opencode 閰嶇疆锛?opencode/oh-my-opencode.json 鎴?~/.config/opencode/oh-my-opencode.json'      );      return;    }    const doc = await vscode.workspace.openTextDocument(vscode.Uri.file(target));    await vscode.window.showTextDocument(doc, { preview: false });  }  private async pickExistingPath(paths: string[]): Promise<string | undefined> {    for (const p of paths) {      try {        await vscode.workspace.fs.stat(vscode.Uri.file(p));        return p;      } catch {        // ignore      }    }    return undefined;  }  private async launchChannel(    channelId: string,    options: {      resume: string | null;      cwd: string | undefined;      initialMessage: any | undefined;      model?: string | null;      variant?: string | null;      permissionMode?: string;      workMode?: string;      thinkingLevel?: string | null;      resumeSessionAt?: string | null;    }  ): Promise<void> {    const workspaceCwd =      this.workspaceService.getDefaultWorkspaceFolder()?.uri.fsPath ?? process.cwd();    const resolvedCwd = options.cwd ?? workspaceCwd;    const sessionId =      options.resume ?? (await this.createSessionForChannel(resolvedCwd, options.initialMessage));    const existing = this.channels.get(channelId);    if (existing) {      // Re-launch: replace session binding      try {        existing.sseAbort.abort();      } catch {}      await this.cleanupTempFiles(existing);      this.channels.delete(channelId);    }    const state: ChannelState = {      channelId,      cwd: resolvedCwd,      sessionId,      modelSetting: typeof options.model === 'string' ? options.model : undefined,      variant: typeof options.variant === 'string' ? options.variant : undefined,      permissionMode:        typeof options.permissionMode === 'string' ? options.permissionMode : undefined,      workMode:        typeof options.workMode === 'string' && options.workMode ? options.workMode : undefined,      thinkingLevel: typeof options.thinkingLevel === 'string' ? options.thinkingLevel : undefined,      running: false,      sseAbort: new AbortController(),      assistantMessageIds: new Set<string>(),      textParts: new Map(),      pendingTextParts: new Map(),      reasoningParts: new Map(),      sentToolUseIds: new Set<string>(),      toolOutputByToolUseId: new Map(),      tempFiles: new Set()    };    this.channels.set(channelId, state);    this.lastActiveChannelId = channelId;    this.startSseLoop(state).catch((error) => {      this.logService.error(`[OpencodeAgentService] SSE loop failed: ${String(error)}`);      this.sendToChannel(channelId, {        type: 'result',        is_error: true,        message: String(error)      });    });    // Tell UI the session id.    // Note: Session.preloadConnection() launches a channel without sending a prompt, and the WebView    // treats system(subtype=init) as "busy" until it receives a result. Only use init when starting a run.    this.sendToChannel(channelId, {      type: 'system',      subtype: options.initialMessage ? 'init' : 'session',      session_id: sessionId,      timestamp: Date.now()    });    if (options.resumeSessionAt) {      // TODO: map to OpenCode fork/revert semantics when implementing "resume at message".      this.logService.info(        `[OpencodeAgentService] resumeSessionAt requested (not yet implemented): ${String(options.resumeSessionAt)}`      );    }    if (options.initialMessage) {      await this.sendPrompt(state, options.initialMessage);    }  }  private async createSessionForChannel(    cwd: string,    initialMessage: any | undefined  ): Promise<string> {    const title =      this.deriveTitle(initialMessage) ?? this.deriveDefaultSessionTitle(cwd) ?? 'OpenCode Session';    const session = await this.client.createSession({ title }, cwd);    const sessionId = String(session?.id ?? session?.sessionID ?? session);    if (!sessionId) {      throw new Error('Failed to create OpenCode session (missing id)');    }    return sessionId;  }  private deriveDefaultSessionTitle(cwd: string): string | undefined {    const ws = this.workspaceService.getDefaultWorkspaceFolder()?.name;    const base = (ws ?? '').trim() || path.basename(String(cwd ?? '').trim() || '');    if (!base) return undefined;    const now = new Date();    const hh = String(now.getHours()).padStart(2, '0');    const mm = String(now.getMinutes()).padStart(2, '0');    return `${base} 鈥?${hh}:${mm}`;  }  private deriveTitle(initialMessage: any | undefined): string | undefined {    const text = initialMessage ? this.extractUserText(initialMessage) : '';    const cleaned = text.replace(/\s+/g, ' ').trim();    if (!cleaned) return undefined;    return cleaned.length > 60 ? cleaned.slice(0, 60) : cleaned;  }  private deriveTitleFromText(input: string): string | undefined {    const cleaned = String(input ?? '')      .replace(/\s+/g, ' ')      .trim();    if (!cleaned) return undefined;    return cleaned.length > 60 ? cleaned.slice(0, 60) : cleaned;  }  private async maybeRenameSessionFromInput(    state: ChannelState,    trimmedInput: string  ): Promise<void> {    if ((state as any).didAutoRenameTitle) return;    if (!trimmedInput) return;    const title = this.deriveTitleFromText(trimmedInput);    if (!title) return;    try {      await this.client.updateSession(state.sessionId, { title }, state.cwd);      (state as any).didAutoRenameTitle = true;    } catch (error) {      this.logService.warn(`[OpencodeAgentService] updateSession title failed: ${String(error)}`);    }  }  private async onIoMessage(channelId: string, message: any): Promise<void> {    const state = this.channels.get(channelId);    if (!state) {      this.logService.warn(`[OpencodeAgentService] io_message for missing channel: ${channelId}`);      return;    }    this.lastActiveChannelId = channelId;    await this.sendPrompt(state, message);  }  private async interrupt(channelId: string): Promise<void> {    const state = this.channels.get(channelId);    if (!state) return;    try {      await this.client.abort(state.sessionId, state.cwd);    } catch (error) {      this.logService.warn(`[OpencodeAgentService] abort failed: ${String(error)}`);    } finally {      state.running = false;      this.flushPendingAssistantOutput(state);      this.flushPendingUsage(state);      this.sendToChannel(channelId, { type: 'result', timestamp: Date.now() });    }  }  private closeChannel(channelId: string): void {    const state = this.channels.get(channelId);    if (state) {      try {        state.sseAbort.abort();      } catch {}      void this.cleanupTempFiles(state);      this.channels.delete(channelId);    }    this.transport?.send({ type: 'close_channel', channelId });  }  private async sendPrompt(state: ChannelState, userMessage: any): Promise<void> {    try {      const text = this.extractUserText(userMessage);      const trimmed = (text ?? '').trim();      void this.maybeRenameSessionFromInput(state, trimmed);      const modelSetting = this.getEffectiveModelSetting(state);      const requestedAgent = this.getEffectiveAgentName(state);      const selectedAgent =        requestedAgent === 'plan' || requestedAgent === 'build'          ? await this.resolvePrimaryAgentName(state.cwd, requestedAgent)          : requestedAgent;      const variant = (state.variant ?? '').trim();      // 1) Slash command: "/command arg1 arg2"      if (trimmed.startsWith('/') && trimmed.length > 1) {        const commandLine = trimmed.slice(1).trimStart();        const firstSpace = commandLine.search(/\s/);        const command = (firstSpace === -1 ? commandLine : commandLine.slice(0, firstSpace)).trim();        const args = firstSpace === -1 ? '' : commandLine.slice(firstSpace).trimStart();        if (command) {          const normalized = command.toLowerCase();          if (normalized === 'undo') {            await this.handleSessionUndo(state);            return;          }          if (normalized === 'redo') {            await this.handleSessionRedo(state);            return;          }          if (normalized === 'compact' || normalized === 'summarize') {            await this.handleSessionCompact(state);            return;          }          const body: any = { command, arguments: args };          if (selectedAgent) body.agent = selectedAgent;          if (modelSetting) body.model = modelSetting;          if (variant) body.variant = variant;          this.beginRun(state);          await this.client.command(state.sessionId, body, state.cwd);          return;        }      }      // 2) Shell command: "!ls -la"      if (trimmed.startsWith('!') && trimmed.length > 1) {        const cmd = trimmed.slice(1).trimStart();        if (cmd) {          const model = this.parseModel(modelSetting);          const body: any = { agent: selectedAgent || 'build', command: cmd };          if (model) body.model = model;          if (variant) body.variant = variant;          this.beginRun(state);          await this.client.shell(state.sessionId, body, state.cwd);          return;        }      }      // 3) Regular prompt      const model = this.parseModel(modelSetting);      const body: any = { parts: await this.buildPromptParts(state, userMessage) };      if (model) body.model = model;      if (selectedAgent) body.agent = selectedAgent;      if (variant) body.variant = variant;      this.beginRun(state);      await this.client.prompt(state.sessionId, body, state.cwd);    } catch (error) {      const msg = error instanceof Error ? error.message : String(error);      this.logService.error(`[OpencodeAgentService] prompt failed: ${msg}`);      this.sendToChannel(state.channelId, {        type: 'assistant',        timestamp: Date.now(),        message: {          role: 'assistant',          content: [{ type: 'text', text: msg }]        }      });      this.finishRun(state, { force: true, isError: true, message: msg });    }  }  private async abortSessionIfRunning(state: ChannelState): Promise<void> {    if (!state.running) return;    // When the user triggers a session-level command while a run is active, we abort first.    // We must *not* emit a "result" from the abort idle event, otherwise the WebView may    // think the command completed and start processing queued messages.    const waitForIdle = new Promise<void>((resolve, reject) => {      state.abortIdleWaiter = { resolve, reject };    });    state.suppressNextIdleResult = true;    try {      await this.client.abort(state.sessionId, state.cwd);    } catch (error) {      this.logService.warn(`[OpencodeAgentService] abort failed: ${String(error)}`);    }    const timeoutMs = 10_000;    await Promise.race([      waitForIdle,      new Promise<void>((resolve) => setTimeout(resolve, timeoutMs))    ]).catch(() => {});    state.abortIdleWaiter = undefined;    state.suppressNextIdleResult = false;    this.resetRealtimeBuffers(state);  }  private resetRealtimeBuffers(state: ChannelState): void {    state.assistantMessageIds.clear();    state.textParts.clear();    state.pendingTextParts.clear();    state.reasoningParts.clear();    state.sentToolUseIds.clear();    state.toolOutputByToolUseId.clear();    state.pendingUsage = undefined;    state.lastUsageMessageId = undefined;    state.lastUsageSignature = undefined;  }  private extractSessionRevertMessageId(session: any): string | undefined {    const value =      session?.revert?.messageID ??      session?.revert?.messageId ??      session?.revert?.message_id ??      session?.revertMessageID ??      session?.revertMessageId ??      '';    const id = String(value ?? '').trim();    return id || undefined;  }  private async listUserMessageIds(state: ChannelState): Promise<string[]> {    const raw = await this.client.listMessages(state.sessionId, state.cwd);    const items: any[] = Array.isArray(raw) ? raw : (raw?.messages ?? raw?.data ?? []);    const out: string[] = [];    for (const item of items) {      const info = item?.info ?? item?.message ?? item;      const role = String(info?.role ?? '').trim();      const id = String(info?.id ?? '').trim();      if (role === 'user' && id) out.push(id);    }    out.sort((a, b) => a.localeCompare(b));    return out;  }  private sendRefreshEvent(state: ChannelState): void {    this.sendToChannel(state.channelId, {      type: 'system',      subtype: 'refresh',      session_id: state.sessionId,      timestamp: Date.now()    });  }  private async handleSessionUndo(state: ChannelState): Promise<void> {    await this.abortSessionIfRunning(state);    this.beginRun(state);    try {      const session = await this.client.getSession(state.sessionId, state.cwd);      const revertMessageId = this.extractSessionRevertMessageId(session);      const userIds = await this.listUserMessageIds(state);      let target: string | undefined;      if (revertMessageId) {        for (const id of userIds) {          if (id < revertMessageId) target = id;        }      } else {        target = userIds.at(-1);      }      if (!target) {        this.sendToChannel(state.channelId, {          type: 'assistant',          timestamp: Date.now(),          message: {            role: 'assistant',            content: [{ type: 'text', text: '娌℃湁鍙挙閿€鐨勪笂涓€鏉℃秷鎭€? }]          }        });        this.finishRun(state);        return;      }      await this.client.revert(state.sessionId, { messageID: target }, state.cwd);      this.resetRealtimeBuffers(state);      this.sendRefreshEvent(state);      this.finishRun(state, { skipRefresh: true });    } catch (error) {      const msg = error instanceof Error ? error.message : String(error);      this.logService.warn(`[OpencodeAgentService] /undo failed: ${msg}`);      this.sendToChannel(state.channelId, {        type: 'assistant',        timestamp: Date.now(),        message: { role: 'assistant', content: [{ type: 'text', text: msg }] }      });      this.finishRun(state, { force: true, isError: true, message: msg });    }  }  private async handleSessionRedo(state: ChannelState): Promise<void> {    await this.abortSessionIfRunning(state);    this.beginRun(state);    try {      const session = await this.client.getSession(state.sessionId, state.cwd);      const revertMessageId = this.extractSessionRevertMessageId(session);      if (!revertMessageId) {        this.sendToChannel(state.channelId, {          type: 'assistant',          timestamp: Date.now(),          message: {            role: 'assistant',            content: [{ type: 'text', text: '褰撳墠娌℃湁鍙噸鍋氱殑鎾ら攢璁板綍銆? }]          }        });        this.finishRun(state);        return;      }      const userIds = await this.listUserMessageIds(state);      const next = userIds.find((id) => id > revertMessageId);      if (!next) {        await this.client.unrevert(state.sessionId, state.cwd);        this.resetRealtimeBuffers(state);        this.sendRefreshEvent(state);        this.finishRun(state, { skipRefresh: true });        return;      }      await this.client.revert(state.sessionId, { messageID: next }, state.cwd);      this.resetRealtimeBuffers(state);      this.sendRefreshEvent(state);      this.finishRun(state, { skipRefresh: true });    } catch (error) {      const msg = error instanceof Error ? error.message : String(error);      this.logService.warn(`[OpencodeAgentService] /redo failed: ${msg}`);      this.sendToChannel(state.channelId, {        type: 'assistant',        timestamp: Date.now(),        message: { role: 'assistant', content: [{ type: 'text', text: msg }] }      });      this.finishRun(state, { force: true, isError: true, message: msg });    }  }  private async handleSessionCompact(state: ChannelState): Promise<void> {    await this.abortSessionIfRunning(state);    this.beginRun(state);    try {      const modelSetting = this.getEffectiveModelSetting(state);      const model = this.parseModel(modelSetting);      if (!model) {        this.sendToChannel(state.channelId, {          type: 'assistant',          timestamp: Date.now(),          message: {            role: 'assistant',            content: [{ type: 'text', text: '璇峰厛鍦ㄩ《閮ㄩ€夋嫨鐢ㄤ簬鍘嬬缉鐨勬ā鍨嬶紙provider/model锛夈€? }]          }        });        this.finishRun(state);        return;      }      state.needsRefreshAfterIdle = true;      await this.client.summarize(        state.sessionId,        { providerID: model.providerID, modelID: model.modelID },        state.cwd      );      // Summarize runs asynchronously; output arrives via SSE and will finish on session.idle.    } catch (error) {      state.needsRefreshAfterIdle = false;      const msg = error instanceof Error ? error.message : String(error);      this.logService.warn(`[OpencodeAgentService] /compact failed: ${msg}`);      this.sendToChannel(state.channelId, {        type: 'assistant',        timestamp: Date.now(),        message: { role: 'assistant', content: [{ type: 'text', text: msg }] }      });      this.finishRun(state, { force: true, isError: true, message: msg });    }  }  private beginRun(state: ChannelState): void {    state.running = true;    this.sendToChannel(state.channelId, {      type: 'system',      subtype: 'init',      session_id: state.sessionId,      timestamp: Date.now()    });  }  private extractUserText(userMessage: any): string {    const content = userMessage?.message?.content ?? userMessage?.content ?? userMessage;    if (typeof content === 'string') return content;    if (Array.isArray(content)) {      return content        .map((b: any) => {          if (!b || typeof b !== 'object') return '';          if (b.type === 'text' && typeof b.text === 'string') return b.text;          return '';        })        .join('\n');    }    return String(content ?? '');  }  private getEffectiveModelSetting(state: ChannelState): string {    const fromState = (state.modelSetting ?? '').trim();    if (fromState) return fromState;    return (this.configService.getValue<string>('opencodeGui.selectedModel', '') ?? '').trim();  }  private getEffectiveAgentName(state: ChannelState): string {    const permissionMode = (state.permissionMode ?? 'default').trim();    if (permissionMode === 'plan') {      return 'plan';    }    const configured = (      this.configService.getValue<string>('opencodeGui.selectedAgent', '') ?? ''    ).trim();    if (configured) return configured;    return 'build';  }  private async resolvePrimaryAgentName(    cwd: string,    requested: 'build' | 'plan'  ): Promise<string> {    const key = process.platform === 'win32' ? cwd.toLowerCase() : cwd;    const cached = this.resolvedPrimaryAgentsByCwd.get(key) ?? {};    const hit = requested === 'plan' ? cached.plan : cached.build;    if (hit) return hit;    let resolved: string = requested;    try {      const raw = await this.client.listAgents(cwd);      const agents: any[] = Array.isArray(raw) ? raw : (raw?.agents ?? []);      const names = new Set(        agents          .map((a) => String(a?.name ?? a?.id ?? a?.slug ?? '').trim())          .filter(Boolean)          .map((n) => (process.platform === 'win32' ? n.toLowerCase() : n))      );      const has = (name: string) =>        names.has(process.platform === 'win32' ? name.toLowerCase() : name);      if (requested === 'plan') {        if (has('plan')) resolved = 'plan';        else if (has('planner-sisyphus')) resolved = 'planner-sisyphus';      } else {        if (has('build')) resolved = 'build';      }    } catch {      // ignore and fall back    }    this.resolvedPrimaryAgentsByCwd.set(key, { ...cached, [requested]: resolved });    return resolved;  }  private async buildPromptParts(state: ChannelState, userMessage: any): Promise<any[]> {    const content = userMessage?.message?.content ?? userMessage?.content;    if (!Array.isArray(content)) {      return [{ type: 'text', text: this.extractUserText(userMessage) }];    }    const parts: any[] = [];    let unnamedFileIndex = 1;    const safeFilename = (input: string): string => {      const base = path.basename(String(input ?? '').trim() || '');      const cleaned = base.replace(/[<>:"/\\|?*\u0000-\u001F]+/g, '_').trim();      return cleaned || `attachment-${unnamedFileIndex}`;    };    const writeTempAttachment = async (filename: string, data: Buffer): Promise<string> => {      const baseDir = path.join(os.tmpdir(), 'opencode-gui-vscode', 'attachments', state.sessionId);      await fs.mkdir(baseDir, { recursive: true });      const unique = `${Date.now()}-${Math.random().toString(36).slice(2)}`;      const fullPath = path.join(baseDir, `${unique}-${safeFilename(filename)}`);      await fs.writeFile(fullPath, data);      state.tempFiles.add(fullPath);      return vscode.Uri.file(fullPath).toString();    };    for (const block of content) {      if (!block || typeof block !== 'object') continue;      if (block.type === 'text' && typeof (block as any).text === 'string') {        parts.push({ type: 'text', text: String((block as any).text) });        continue;      }      if (block.type === 'image') {        const src = (block as any).source;        if (src?.type === 'base64' && typeof src?.data === 'string') {          const mime = String(src?.media_type ?? src?.mediaType ?? 'application/octet-stream');          const filename =            typeof (block as any).title === 'string'              ? String((block as any).title)              : `attachment-${unnamedFileIndex++}`;          const url = await writeTempAttachment(filename, Buffer.from(src.data, 'base64'));          parts.push({            type: 'file',            mime,            filename,            url          });        }        continue;      }      if (block.type === 'document') {        const src = (block as any).source;        const mime = String(src?.media_type ?? src?.mediaType ?? 'application/octet-stream');        let bytes: Buffer | undefined;        if (src?.type === 'base64' && typeof src?.data === 'string') {          bytes = Buffer.from(src.data, 'base64');        } else if (src?.type === 'text' && typeof src?.data === 'string') {          bytes = Buffer.from(src.data, 'utf8');        }        if (bytes) {          const filename =            typeof (block as any).title === 'string'              ? String((block as any).title)              : `attachment-${unnamedFileIndex++}`;          const url = await writeTempAttachment(filename, bytes);          parts.push({            type: 'file',            mime,            filename,            url          });        }        continue;      }    }    if (parts.length === 0) {      parts.push({ type: 'text', text: this.extractUserText(userMessage) });    }    return parts;  }  private parseModel(value: string): { providerID: string; modelID: string } | undefined {    if (!value) return undefined;    const idx = value.indexOf('/');    if (idx <= 0 || idx === value.length - 1) return undefined;    const providerID = value.slice(0, idx).trim();    const modelID = value.slice(idx + 1).trim();    if (!providerID || !modelID) return undefined;    return { providerID, modelID };  }  private async startSseLoop(state: ChannelState): Promise<void> {    let attempt = 0;    while (!state.sseAbort.signal.aborted) {      try {        for await (const evt of this.client.subscribeEvents(state.cwd, state.sseAbort.signal)) {          attempt = 0;          await this.handleEvent(state, evt);          if (state.sseAbort.signal.aborted) break;        }      } catch (error) {        if (state.sseAbort.signal.aborted) break;        attempt += 1;        const delayMs = Math.min(5000, 250 * Math.pow(2, Math.min(attempt, 5)));        this.logService.warn(          `[OpencodeAgentService] SSE disconnected (attempt ${attempt}), retrying in ${delayMs}ms: ${String(error)}`        );        await new Promise((resolve) => setTimeout(resolve, delayMs));        continue;      }      if (state.sseAbort.signal.aborted) break;      attempt += 1;      const delayMs = Math.min(3000, 250 * Math.pow(2, Math.min(attempt, 4)));      this.logService.warn(        `[OpencodeAgentService] SSE ended unexpectedly, retrying in ${delayMs}ms (attempt ${attempt})`      );      await new Promise((resolve) => setTimeout(resolve, delayMs));    }  }  private async handleEvent(state: ChannelState, evt: OpencodeEvent): Promise<void> {    switch (evt.type) {      case 'message.updated':        this.onMessageUpdated(state, evt);        return;      case 'message.part.updated':        this.onMessagePartUpdated(state, evt);        return;      case 'permission.asked':      case 'permission.updated':        await this.onPermissionUpdated(state, evt);        return;      case 'session.status':        this.onSessionStatus(state, evt);        return;      case 'session.idle':        this.onSessionIdle(state, evt);        return;      case 'session.error':        this.onSessionError(state, evt);        return;      default:        return;    }  }  private normalizeSessionId(value: unknown): string | undefined {    if (!value) return undefined;    const s = String(value);    return s ? s : undefined;  }  private getEventSessionId(evt: OpencodeEvent): string | undefined {    const props: any = evt.properties as any;    return this.normalizeSessionId(props?.sessionID ?? props?.sessionId ?? props?.id);  }  private normalizeToolName(name: string): string {    const raw = (name ?? '').trim();    if (!raw) return raw;    if (raw.startsWith('mcp__')) return raw;    // If it's already PascalCase (as expected by the WebView tool renderer), keep it.    if (/[A-Z]/.test(raw) && !raw.includes('_') && !raw.includes('-')) {      return raw;    }    const key = raw.toLowerCase();    const known: Record<string, string> = {      read: 'Read',      write: 'Write',      edit: 'Edit',      bash: 'Bash',      glob: 'Glob',      grep: 'Grep',      task: 'Task',      todowrite: 'TodoWrite',      todo_write: 'TodoWrite',      'todo-write': 'TodoWrite',      webfetch: 'WebFetch',      web_fetch: 'WebFetch',      'web-fetch': 'WebFetch',      websearch: 'WebSearch',      web_search: 'WebSearch',      'web-search': 'WebSearch',      bashoutput: 'BashOutput',      bash_output: 'BashOutput',      'bash-output': 'BashOutput',      killshell: 'KillShell',      kill_shell: 'KillShell',      'kill-shell': 'KillShell',      exitplanmode: 'ExitPlanMode',      exit_plan_mode: 'ExitPlanMode',      'exit-plan-mode': 'ExitPlanMode',      multiedit: 'MultiEdit',      multi_edit: 'MultiEdit',      'multi-edit': 'MultiEdit',      notebookedit: 'NotebookEdit',      notebook_edit: 'NotebookEdit',      'notebook-edit': 'NotebookEdit',      slashcommand: 'SlashCommand',      slash_command: 'SlashCommand',      'slash-command': 'SlashCommand'    };    if (known[key]) return known[key];    // Fallback: snake/kebab -> PascalCase    const words = raw.split(/[^a-zA-Z0-9]+/).filter(Boolean);    if (words.length === 0) return raw;    return words.map((w) => w.slice(0, 1).toUpperCase() + w.slice(1)).join('');  }  private onSessionStatus(state: ChannelState, evt: OpencodeEvent): void {    const sessionID = this.getEventSessionId(evt);    if (!sessionID || sessionID !== state.sessionId) return;    const props: any = evt.properties as any;    const status: any = props?.status;    const type = typeof status === 'string' ? status : status?.type;    if (type === 'idle') {      this.onSessionIdle(state, evt);    }  }  private onMessageUpdated(state: ChannelState, evt: OpencodeEvent): void {    const info = (evt.properties as any)?.info as OpenCodeMessageInfo | undefined;    if (!info || info.sessionID !== state.sessionId) return;    if (info.role === 'assistant') {      state.assistantMessageIds.add(info.id);      // Promote any buffered text parts once we learn this message is from the assistant.      for (const [partId, part] of state.pendingTextParts) {        if (part.messageID !== info.id) continue;        state.textParts.set(partId, part);        state.pendingTextParts.delete(partId);      }      const usage = this.toClaudeUsage((info as any)?.tokens);      if (usage) {        const sig = JSON.stringify(usage);        if (state.lastUsageMessageId !== info.id || state.lastUsageSignature !== sig) {          state.lastUsageMessageId = info.id;          state.lastUsageSignature = sig;          state.pendingUsage = { messageId: info.id, usage };          this.flushPendingUsage(state);        }      }      return;    }    if (info.role === 'user') {      // Drop buffered user message text parts (user prompts are rendered by the WebView already).      for (const [partId, part] of state.pendingTextParts) {        if (part.messageID !== info.id) continue;        state.pendingTextParts.delete(partId);      }    }  }  private onMessagePartUpdated(state: ChannelState, evt: OpencodeEvent): void {    const part = (evt.properties as any)?.part as any;    if (!part || typeof part !== 'object' || part.sessionID !== state.sessionId) return;    const delta = (evt.properties as any)?.delta as string | undefined;    switch (part.type) {      case 'text': {        const tp = part as OpenCodeTextPart;        if (state.assistantMessageIds.has(part.messageID)) {          this.upsertDelta(state.textParts, tp.id, tp.messageID, delta, tp.text);        } else {          // Message role may arrive after parts; buffer until message.updated tells us it's assistant.          this.upsertDelta(state.pendingTextParts, tp.id, tp.messageID, delta, tp.text);        }        return;      }      case 'reasoning': {        state.assistantMessageIds.add(part.messageID);        const rp = part as OpenCodeReasoningPart;        this.upsertDelta(state.reasoningParts, rp.id, rp.messageID, delta, rp.text);        return;      }      case 'tool':        state.assistantMessageIds.add(part.messageID);        {          const toolUseId = String((part as any)?.callID ?? (part as any)?.id ?? '').trim();          if (toolUseId) {            const existing = state.toolOutputByToolUseId.get(toolUseId) ?? '';            if (typeof delta === 'string' && delta) {              state.toolOutputByToolUseId.set(toolUseId, existing + delta);            }            const output = (part as any)?.state?.output;            if (typeof output === 'string' && output && output.length >= existing.length) {              state.toolOutputByToolUseId.set(toolUseId, output);            }          }        }        this.onToolPart(state, part as OpenCodeToolPart);        return;      case 'patch': {        state.assistantMessageIds.add(part.messageID);        const pp = part as OpenCodePatchPart;        state.lastRevert = { messageID: pp.messageID, partID: pp.id };        return;      }      default:        return;    }  }  private upsertDelta(    map: Map<string, { messageID: string; text: string }>,    partId: string,    messageID: string,    delta: string | undefined,    fullText: string  ): void {    const existing = map.get(partId);    if (delta) {      map.set(partId, { messageID, text: (existing?.text ?? '') + delta });    } else {      map.set(partId, { messageID, text: fullText });    }  }  private buildToolUseInput(part: OpenCodeToolPart): Record<string, unknown> {    const toolName = this.normalizeToolName(part.tool);    const input: Record<string, unknown> =      part.state?.input && typeof part.state.input === 'object' && !Array.isArray(part.state.input)        ? { ...part.state.input }        : {};    const raw = (part.state as any)?.raw;    if (typeof raw === 'string' && raw.trim()) {      const parsed = this.parseToolRawInput(raw);      if (parsed) {        for (const [key, value] of Object.entries(parsed)) {          if (input[key] === undefined || input[key] === '') {            input[key] = value;          }        }      }    }    // Normalize common file path keys for tool UIs (Read/Write/Edit/etc).    const knownFilePath =      (typeof input.file_path === 'string' && input.file_path.trim()) ||      (typeof input.path === 'string' && input.path.trim()) ||      (typeof input.filePath === 'string' && input.filePath.trim()) ||      (typeof input.notebook_path === 'string' && input.notebook_path.trim()) ||      (typeof (input as any).filepath === 'string' && String((input as any).filepath).trim()) ||      '';    if (!knownFilePath) {      // OpenCode tool states often include a `title` like "src/foo.ts" even when `input.filePath`      // is empty (pending/running updates). For file-oriented tools, treat the title as the path      // so the UI can render the header.      const title = typeof part.state?.title === 'string' ? part.state.title.trim() : '';      const isFileTool =        toolName === 'Read' ||        toolName === 'Write' ||        toolName === 'Edit' ||        toolName === 'MultiEdit' ||        toolName === 'NotebookEdit';      if (isFileTool && title) {        if (toolName === 'NotebookEdit') {          input.notebook_path = title;        } else {          input.filePath = title;        }      }      const inferred = this.extractFilePathFromTitle(part.state?.title);      if (inferred) {        input.filePath = inferred;      }    } else if (typeof (input as any).filepath === 'string' && !input.filePath && !input.file_path) {      input.filePath = String((input as any).filepath);    }    if (part.state?.title !== undefined) {      input.title = part.state.title;    }    if (part.state?.status !== undefined) {      input.status = part.state.status;    }    return input;  }  private parseToolRawInput(raw: string): Record<string, unknown> | undefined {    const text = raw.trim();    if (!text) return undefined;    const tryJson = (value: string): unknown => {      try {        return JSON.parse(value);      } catch {        return undefined;      }    };    const isPlainObject = (value: unknown): value is Record<string, unknown> => {      return !!value && typeof value === 'object' && !Array.isArray(value);    };    if (text.startsWith('{') && text.endsWith('}')) {      const parsed = tryJson(text);      if (isPlainObject(parsed)) return parsed;    }    const start = text.indexOf('{');    const end = text.lastIndexOf('}');    if (start !== -1 && end !== -1 && end > start) {      const candidate = text.slice(start, end + 1);      const parsed = tryJson(candidate);      if (isPlainObject(parsed)) return parsed;    }    const m =      text.match(/\"(?:filePath|file_path|path|notebook_path)\"\\s*:\\s*\"([^\"]+)\"/) ??      text.match(/(?:filePath|file_path|path|notebook_path)\\s*[:=]\\s*['\"]([^'\"]+)['\"]/);    if (m?.[1]) {      return { filePath: m[1] };    }    return undefined;  }  private extractFilePathFromTitle(title: unknown): string | undefined {    const text = typeof title === 'string' ? title.trim() : '';    if (!text) return undefined;    // Windows absolute path: C:\foo\bar or C:/foo/bar (best-effort, may truncate if spaces exist).    const win = text.match(/[a-zA-Z]:[\\/][^\\s]+/);    if (win?.[0]) return win[0];    // POSIX absolute path: /foo/bar (best-effort).    const posix = text.match(/\/[^\s]+/);    if (posix?.[0]) return posix[0];    return undefined;  }  private onToolPart(state: ChannelState, part: OpenCodeToolPart): void {    const toolUseId = part.callID || part.id;    if (!toolUseId) return;    const toolName = this.normalizeToolName(part.tool);    const status = String(part.state?.status ?? '').trim();    const title = String(part.state?.title ?? '').trim();    if (toolName) {      this.pushProgressEvent(        state.channelId,        'tool',        title          ? `${toolName} 鈥?${status || 'running'} 鈥?${title}`          : `${toolName} 鈥?${status || 'running'}`      );    }    const rawInput =      part.state?.input && typeof part.state.input === 'object' && !Array.isArray(part.state.input)        ? part.state.input        : undefined;    const hasRawArgs = !!rawInput && Object.keys(rawInput).length > 0;    // OpenCode frequently emits tool parts as:    // - pending: input is {} (no useful fields)    // - running: input may still be {} for some tools/versions    // - completed/error: input contains the real args (e.g. Read.filePath)    // If we send tool_use too early, the UI can't render the file path and we have no "update tool_use" mechanism.    const shouldSendToolUse =      status === 'completed' || status === 'error' || (status === 'running' && hasRawArgs);    if (shouldSendToolUse && !state.sentToolUseIds.has(toolUseId)) {      state.sentToolUseIds.add(toolUseId);      const input = this.buildToolUseInput(part);      this.sendToChannel(state.channelId, {        type: 'assistant',        timestamp: Date.now(),        message: {          id: part.messageID,          role: 'assistant',          content: [            {              type: 'tool_use',              id: toolUseId,              name: toolName,              input            }          ]        }      });    }    if (part.state.status === 'completed') {      const buffered = state.toolOutputByToolUseId.get(toolUseId) ?? '';      const output = buffered || part.state.output || '';      this.sendToChannel(state.channelId, {        type: 'user',        timestamp: Date.now(),        message: {          role: 'user',          content: [            {              type: 'tool_result',              tool_use_id: toolUseId,              content: output,              is_error: false            }          ]        }      });      state.toolOutputByToolUseId.delete(toolUseId);      return;    }    if (part.state.status === 'error') {      state.toolOutputByToolUseId.delete(toolUseId);      this.sendToChannel(state.channelId, {        type: 'user',        timestamp: Date.now(),        message: {          role: 'user',          content: [            {              type: 'tool_result',              tool_use_id: toolUseId,              content: part.state.error ?? 'Tool error',              is_error: true            }          ]        }      });    }  }  private async onPermissionUpdated(state: ChannelState, evt: OpencodeEvent): Promise<void> {    const p = (evt.properties as any) ?? undefined;    if (!p || typeof p !== 'object') return;    const sid = this.normalizeSessionId(p?.sessionID ?? p?.sessionId);    if (!sid || sid !== state.sessionId) return;    const permissionId = String(p?.id ?? '').trim();    if (!permissionId) return;    const mode = (state.permissionMode ?? 'default').trim();    if (mode === 'bypassPermissions') {      await this.client.respondPermission(state.sessionId, permissionId, 'always', state.cwd, true);      return;    }    if (mode === 'dontAsk') {      await this.client.respondPermission(state.sessionId, permissionId, 'reject', state.cwd);      return;    }    if (mode === 'acceptEdits') {      await this.client.respondPermission(state.sessionId, permissionId, 'once', state.cwd);      return;    }    const requestId = Math.random().toString(36).slice(2);    const responsePromise = new Promise<ToolPermissionResponse>((resolve, reject) => {      this.requestWaiters.set(requestId, { resolve: resolve as any, reject });    });    this.transport?.send({      type: 'request',      channelId: state.channelId,      requestId,      request: {        type: 'tool_permission_request',        toolName: String(p?.permission ?? p?.type ?? 'permission'),        inputs: {          title: String(p?.title ?? p?.permission ?? p?.type ?? 'permission'),          pattern: (p as any)?.pattern ?? undefined,          patterns: Array.isArray((p as any)?.patterns) ? (p as any).patterns : undefined,          always: Array.isArray((p as any)?.always) ? (p as any).always : undefined,          metadata: (p as any)?.metadata ?? {}        },        // Non-empty list enables the "Yes, and don't ask again" UI (mapped to OpenCode "always").        suggestions: Array.isArray((p as any)?.always)          ? ((p as any).always.length > 0 ? ([{} as any] as any) : [])          : ([{} as any] as any)      }    });    const resp = await responsePromise;    const decision = resp?.result;    const remember =      decision?.behavior === 'allow' &&      Array.isArray((decision as any)?.updatedPermissions) &&      (decision as any).updatedPermissions.length > 0;    const opencodeResponse =      decision?.behavior === 'allow' ? (remember ? 'always' : 'once') : 'reject';    await this.client.respondPermission(      state.sessionId,      permissionId,      opencodeResponse,      state.cwd,      remember ? true : undefined    );  }  private onSessionIdle(state: ChannelState, evt: OpencodeEvent): void {    const sessionID = this.getEventSessionId(evt);    if (!sessionID || sessionID !== state.sessionId) return;    this.pushProgressEvent(state.channelId, 'session', 'idle');    if (state.suppressNextIdleResult) {      state.suppressNextIdleResult = false;      const waiter = state.abortIdleWaiter;      state.abortIdleWaiter = undefined;      waiter?.resolve();      return;    }    const shouldRefresh = state.needsRefreshAfterIdle === true;    state.needsRefreshAfterIdle = false;    this.finishRun(state, shouldRefresh ? { skipRefresh: true } : undefined);    if (shouldRefresh) {      this.resetRealtimeBuffers(state);      this.sendRefreshEvent(state);    }  }  private onSessionError(state: ChannelState, evt: OpencodeEvent): void {    const sessionID = this.getEventSessionId(evt);    if (sessionID && sessionID !== state.sessionId) return;    const err = (evt.properties as any)?.error;    const msg = err?.data?.message ?? err?.data?.providerID ?? 'OpenCode session error';    this.pushProgressEvent(state.channelId, 'session', `error: ${String(msg)}`);    state.needsRefreshAfterIdle = false;    if (state.suppressNextIdleResult && state.abortIdleWaiter) {      state.suppressNextIdleResult = false;      const waiter = state.abortIdleWaiter;      state.abortIdleWaiter = undefined;      waiter.reject(new Error(String(msg)));    }    this.sendToChannel(state.channelId, {      type: 'assistant',      timestamp: Date.now(),      message: {        id: (err as any)?.messageID ?? undefined,        role: 'assistant',        content: [{ type: 'text', text: String(msg) }]      }    });    this.finishRun(state, { force: true, isError: true, message: String(msg) });  }  private finishRun(    state: ChannelState,    options?: { force?: boolean; isError?: boolean; message?: string; skipRefresh?: boolean }  ): void {    const force = options?.force === true;    if (!force && !state.running) return;    state.running = false;    this.flushPendingAssistantOutput(state);    this.flushPendingUsage(state);    this.sendToChannel(state.channelId, {      type: 'result',      is_error: options?.isError ? true : undefined,      message: options?.message,      timestamp: Date.now()    });    if (options?.skipRefresh !== true) {      this.scheduleRefreshEvent(state);    }  }  private scheduleRefreshEvent(state: ChannelState): void {    const now = Date.now();    const last = state.lastAutoRefreshAt ?? 0;    // Throttle refresh to avoid flooding when multiple finishRun() happen back-to-back.    if (now - last < 250) return;    state.lastAutoRefreshAt = now;    // Defer so the WebView can process the final tool/result events first.    setTimeout(() => {      if (state.running) return;      this.sendRefreshEvent(state);    }, 0);  }  private flushPendingUsage(state: ChannelState): void {    const usage = state.pendingUsage?.usage;    if (!usage) return;    const messageId = state.pendingUsage?.messageId ?? null;    state.pendingUsage = undefined;    this.sendToChannel(state.channelId, {      type: 'assistant',      timestamp: Date.now(),      message: {        id: messageId,        role: 'assistant',        content: [],        usage      }    });  }  private toClaudeUsage(tokens: any): Record<string, unknown> | undefined {    if (!tokens || typeof tokens !== 'object') return undefined;    const input = Number((tokens as any).input ?? (tokens as any).input_tokens);    const output = Number((tokens as any).output ?? (tokens as any).output_tokens);    const reasoning = Number((tokens as any).reasoning ?? (tokens as any).reasoning_tokens ?? 0);    const cacheRead = Number(      (tokens as any)?.cache?.read ?? (tokens as any).cache_read ?? (tokens as any).cacheRead ?? 0    );    const cacheWrite = Number(      (tokens as any)?.cache?.write ??        (tokens as any).cache_write ??        (tokens as any).cacheWrite ??        0    );    const hasAny =      Number.isFinite(input) ||      Number.isFinite(output) ||      Number.isFinite(reasoning) ||      Number.isFinite(cacheRead) ||      Number.isFinite(cacheWrite);    if (!hasAny) return undefined;    return {      input_tokens: Number.isFinite(input) ? input : 0,      output_tokens: (Number.isFinite(output) ? output : 0) + (Number.isFinite(reasoning) ? reasoning : 0),      cache_read_input_tokens: Number.isFinite(cacheRead) ? cacheRead : 0,      cache_creation_input_tokens: Number.isFinite(cacheWrite) ? cacheWrite : 0    };  }  private async cleanupTempFiles(state: ChannelState): Promise<void> {    if (!state.tempFiles || state.tempFiles.size === 0) return;    const files = Array.from(state.tempFiles);    state.tempFiles.clear();    await Promise.all(      files.map(async (filePath) => {        try {          await fs.unlink(filePath);        } catch {          // ignore        }      })    );  }  private flushPendingAssistantOutput(state: ChannelState): void {    const thinking = Array.from(state.reasoningParts.values())      .map((p) => p.text)      .join('');    const pendingText = Array.from(state.pendingTextParts.values())      .filter((p) => state.assistantMessageIds.has(p.messageID))      .map((p) => p.text)      .join('');    const text =      Array.from(state.textParts.values())        .map((p) => p.text)        .join('') + pendingText;    state.reasoningParts.clear();    state.textParts.clear();    state.pendingTextParts.clear();    if (thinking.trim()) {      this.sendToChannel(state.channelId, {        type: 'assistant',        timestamp: Date.now(),        message: {          id: null,          role: 'assistant',          content: [{ type: 'thinking', thinking }]        }      });    }    if (text.trim()) {      this.sendToChannel(state.channelId, {        type: 'assistant',        timestamp: Date.now(),        message: {          id: null,          role: 'assistant',          content: [{ type: 'text', text }]        }      });    }  }  private async handleRequestMessage(message: RequestMessage): Promise<void> {    try {      const response = await this.dispatchRequest(message);      this.transport?.send({ type: 'response', requestId: message.requestId, response });    } catch (error) {      const err: ErrorResponse = {        type: 'error',        error: error instanceof Error ? error.message : String(error)      };      this.transport?.send({ type: 'response', requestId: message.requestId, response: err });    }  }  private handleResponseMessage(message: ResponseMessage): void {    const waiter = this.requestWaiters.get(message.requestId);    if (!waiter) return;    this.requestWaiters.delete(message.requestId);    const resp: any = (message as any).response;    if (resp && resp.type === 'error') {      waiter.reject(new Error(resp.error));    } else {      waiter.resolve(resp);    }  }  private async dispatchRequest(    message: RequestMessage  ): Promise<    | InitResponse    | GetClaudeStateResponse    | GetClaudeConfigResponse    | SaveClaudeConfigResponse    | GetCurrentSelectionResponse    | GetMcpServersResponse    | GetAssetUrisResponse    | ListSessionsResponse    | GetSessionResponse    | GetAgentsResponse    | ToggleAgentResponse    | DeleteAgentResponse    | GetSkillsResponse    | ToggleSkillResponse    | DeleteSkillResponse    | SetModelResponse    | SetVariantResponse    | SetPermissionModeResponse    | SetThinkingLevelResponse    | GetProgressResponse    | ListFilesResponse    | ShowNotificationResponse    | OpenContentResponse    | OpenDiffResponse    | ExecResponse    | OpenConfigFileResponse    | OpenClaudeInTerminalResponse    | NewConversationTabResponse    | RenameTabResponse    | any  > {    const req: any = (message as any).request;    switch (req?.type) {      case 'init':        return this.handleInit();      case 'get_claude_state':        return this.handleGetClaudeState();      case 'get_claude_config':        return this.handleGetClaudeConfig(req.scope, req.configType);      case 'save_claude_config':        return this.handleSaveClaudeConfig(req.config, req.scope, req.configType);      case 'get_current_selection':        return this.handleGetCurrentSelection();      case 'get_mcp_servers':        return this.handleGetMcpServers();      case 'get_asset_uris':        return this.handleGetAssetUris();      case 'list_sessions_request':        return this.handleListSessions();      case 'get_session_request':        return this.handleGetSession(String(req.sessionId));      case 'list_files_request':        return this.handleListFiles(req.pattern);      case 'get_progress':        return {          type: 'get_progress_response',          progress: this.getProgressSnapshot(undefined)        };      case 'set_model':        {          const model = String(req.model?.value ?? '').trim();          await this.configService.updateValue('opencodeGui.selectedModel', model);          const channelId = message.channelId;          const state = channelId ? this.channels.get(channelId) : undefined;          if (state) {            state.modelSetting = model;          }        }        return { type: 'set_model_response', success: true };      case 'set_permission_mode':        {          const channelId = message.channelId;          const state = channelId ? this.channels.get(channelId) : undefined;          const mode = String(req.mode ?? '').trim();          if (state && mode) {            state.permissionMode = mode;          }        }        return { type: 'set_permission_mode_response', success: true };      case 'set_variant':        {          const channelId = message.channelId;          const state = channelId ? this.channels.get(channelId) : undefined;          const variant = String(req.variant ?? '').trim();          if (state) {            state.variant = variant || undefined;          }        }        return { type: 'set_variant_response', success: true };      case 'set_thinking_level':        {          const channelId = message.channelId ?? req.channelId;          const state = channelId ? this.channels.get(String(channelId)) : undefined;          const level = String(req.thinkingLevel ?? '').trim();          if (state && level) {            state.thinkingLevel = level;          }        }        return { type: 'set_thinking_level_response' };      case 'open_file':        await this.openFile(String(req.filePath), req.location);        return { type: 'open_file_response' };      case 'open_content':        return this.handleOpenContent(          String(req.content ?? ''),          String(req.fileName ?? 'opencode.txt'),          !!req.editable        );      case 'open_diff':        return this.handleOpenDiff(req);      case 'open_url':        vscode.env.openExternal(vscode.Uri.parse(String(req.url)));        return { type: 'open_url_response' };      case 'show_notification':        return this.handleShowNotification(req as ShowNotificationRequest);      case 'exec':        return this.handleExec(          String(req.command ?? ''),          Array.isArray(req.params) ? req.params : []        );      case 'new_conversation_tab':        return this.handleNewConversationTab();      case 'rename_tab':        return { type: 'rename_tab_response' };      case 'open_config_file':        await this.handleOpenConfigFile(String(req.configType ?? ''));        return { type: 'open_config_file_response' };      case 'get_opencode_config_file':        return this.handleGetOpencodeConfigFile(          String(req.configType ?? ''),          String(req.scope ?? '')        );      case 'save_opencode_config_file':        return this.handleSaveOpencodeConfigFile(          String(req.configType ?? ''),          String(req.scope ?? ''),          String(req.content ?? '')        );      case 'get_opencode_auth_status':        return this.handleGetOpencodeAuthStatus(String(req.providerId ?? ''));      case 'set_opencode_auth_api_key':        return this.handleSetOpencodeAuthApiKey(          String(req.providerId ?? ''),          String(req.apiKey ?? '')        );      case 'open_claude_in_terminal':        await this.handleOpenInTerminal();        return { type: 'open_claude_in_terminal_response' };      case 'get_agents':        return this.handleGetAgents();      case 'toggle_agent':        return this.handleToggleAgent(String(req.agentName ?? ''), !!req.enabled);      case 'delete_agent':        return this.handleDeleteAgent(String(req.agentPath ?? ''));      case 'get_skills':        return this.handleGetSkills();      case 'toggle_skill':        return this.handleToggleSkill(String(req.skillId ?? ''), !!req.enabled);      case 'delete_skill':        return this.handleDeleteSkill(String(req.skillPath ?? ''));      default:        this.logService.warn(`[OpencodeAgentService] Unhandled request: ${String(req?.type)}`);        return { type: 'noop' };    }  }  private handleInit(): InitResponse {    const defaultCwd =      this.workspaceService.getDefaultWorkspaceFolder()?.uri.fsPath ?? process.cwd();    const modelSetting = this.configService.getValue<string>('opencodeGui.selectedModel', '') ?? '';    return {      type: 'init_response',      state: {        defaultCwd,        openNewInTab: false,        modelSetting,        platform: process.platform,        thinkingLevel: 'default_on'      }    };  }  private async handleGetClaudeState(): Promise<GetClaudeStateResponse> {    // WebView 渚ч渶瑕佷竴涓?config 瀵硅薄鏉ュ垵濮嬪寲妯″瀷/Slash Commands銆?    // OpenCode 鐗堟湰鍏堣繑鍥炴渶灏忕粨鏋勶紝鍚庣画鍐嶇敤 /provider /config/providers 绛夎ˉ榻愩€?    const cwd = this.workspaceService.getDefaultWorkspaceFolder()?.uri.fsPath ?? process.cwd();    try {      const raw = await this.client.listConfigProviders(cwd);      const providers: any[] = Array.isArray(raw?.providers) ? raw.providers : [];      let models = this.mapProvidersToModels(providers);      // Fallback: some versions may only expose models via `/provider`.      if (models.length === 0) {        const rawProviders = await this.client.listProviders(cwd);        const providersAlt: any[] = Array.isArray(rawProviders?.all)          ? rawProviders.all          : Array.isArray(rawProviders?.providers)            ? rawProviders.providers            : Array.isArray(rawProviders)              ? rawProviders              : [];        models = this.mapProvidersToModels(providersAlt);      }      let slashCommands: Array<{ name: string; description?: string }> = [];      try {        const rawCommands = await this.client.listCommands(cwd);        const commands: any[] = Array.isArray(rawCommands)          ? rawCommands          : Array.isArray((rawCommands as any)?.commands)            ? (rawCommands as any).commands            : [];        slashCommands = commands          .filter((c) => typeof c?.name === 'string' && String(c.name).trim())          .map((c) => ({            name: String(c.name).trim(),            description: typeof c?.description === 'string' ? c.description : undefined          }))          .sort((a, b) => a.name.localeCompare(b.name));      } catch (error) {        this.logService.warn(`[OpencodeAgentService] Failed to load commands: ${String(error)}`);        slashCommands = [];      }      // OpenCode 鍐呯疆鐨勨€滀細璇濈骇鈥濆懡浠わ紙涓嶅湪 /command 鍒楄〃閲岋紝浣嗙敤鎴蜂細鍦?TUI 閲岀敤 /undo /redo /compact锛夈€?      // 杩欎簺鍛戒护浼氬湪 sendPrompt 涓鐗规畩澶勭悊锛堣皟鐢?session.revert/unrevert/summarize锛夈€?      const extras: Array<{ name: string; description?: string }> = [        { name: 'undo', description: '鎾ら攢涓婁竴鏉℃秷鎭笌鏂囦欢鍙樻洿' },        { name: 'redo', description: '閲嶅仛琚挙閿€鐨勬秷鎭笌鏂囦欢鍙樻洿' },        { name: 'compact', description: '鍘嬬缉涓婁笅鏂囷紙鎬荤粨浼氳瘽锛? },        { name: 'summarize', description: '鍚?/compact锛堝埆鍚嶏級' },        { name: 'init', description: 'Project init (generate AGENTS.md)' },      ];      const existing = new Set(slashCommands.map((c) => c.name));      for (const extra of extras) {        if (!existing.has(extra.name)) {          slashCommands.push(extra);          existing.add(extra.name);        }      }      slashCommands.sort((a, b) => a.name.localeCompare(b.name));      return {        type: 'get_claude_state_response',        config: {          models,          slashCommands        }      };    } catch (error) {      this.logService.warn(`[OpencodeAgentService] Failed to load providers: ${String(error)}`);      return {        type: 'get_claude_state_response',        config: {          models: [],          slashCommands: []        }      };    }  }  private mapProvidersToModels(    providers: any[]  ): Array<{    value: string;    displayName?: string;    description?: string;    variants?: unknown;    contextWindow?: number;  }> {    const out: Array<{      value: string;      displayName?: string;      description?: string;      variants?: unknown;      contextWindow?: number;    }> = [];    for (const p of providers ?? []) {      const providerID = String(p?.id ?? p?.providerID ?? p?.name ?? '').trim();      if (!providerID) continue;      const providerName = String(p?.name ?? providerID);      const providerDesc = typeof p?.description === 'string' ? p.description : undefined;      const modelsRaw = Array.isArray(p?.models)        ? p.models        : p?.models && typeof p.models === 'object'          ? Object.entries(p.models).map(([key, value]) => ({ ...(value as any), __modelKey: key }))          : Array.isArray(p?.modelIDs)            ? p.modelIDs            : Array.isArray(p?.modelIds)              ? p.modelIds              : [];      for (const m of modelsRaw) {        const modelID =          typeof m === 'string'            ? m            : String(                (m as any)?.id ??                  (m as any)?.modelID ??                  (m as any)?.name ??                  (m as any)?.__modelKey ??                  ''              ).trim();        if (!modelID) continue;        const displayName =          typeof m === 'string'            ? `${providerName}/${modelID}`            : String((m as any)?.displayName ?? (m as any)?.name ?? `${providerName}/${modelID}`);        const description =          typeof m === 'string'            ? providerDesc            : String((m as any)?.description ?? providerDesc ?? '');        const variants =          typeof m === 'string'            ? undefined            : (m as any)?.variants && typeof (m as any).variants === 'object'              ? (m as any).variants              : undefined;        const contextWindowRaw =          typeof m === 'string'            ? undefined            : (m as any)?.limit?.context ?? (m as any)?.limits?.context ?? (m as any)?.contextWindow;        const contextWindow = Number(contextWindowRaw);        out.push({          value: `${providerID}/${modelID}`,          displayName,          description: description || undefined,          variants,          contextWindow: Number.isFinite(contextWindow) && contextWindow > 0 ? contextWindow : undefined        });      }    }    out.sort((a, b) =>      String(a.displayName ?? a.value).localeCompare(String(b.displayName ?? b.value))    );    return out;  }  private async handleGetClaudeConfig(    scope: 'user' | 'project' | 'merged' = 'merged',    configType: 'settings' | 'mcp' = 'settings'  ): Promise<GetClaudeConfigResponse> {    const cwd = this.workspaceService.getDefaultWorkspaceFolder()?.uri.fsPath ?? process.cwd();    const userConfig =      scope === 'project'        ? undefined        : await this.readJsonFile(this.getUserGuiConfigPath(configType)).catch(() => undefined);    const projectConfig =      scope === 'user'        ? undefined        : await this.readJsonFile(this.getProjectGuiConfigPath(cwd, configType)).catch(            () => undefined          );    const merged =      scope === 'merged' ? { ...(userConfig ?? {}), ...(projectConfig ?? {}) } : undefined;    const config =      (scope === 'user' ? userConfig : scope === 'project' ? projectConfig : merged) ?? {};    // Provide safe defaults so Settings UI can render without special-casing.    if (!config.env) config.env = {};    if (!config.permissions) config.permissions = { allow: [], deny: [] };    if (!config.mcpServers) config.mcpServers = {};    if (!config.additionalDirectories) config.additionalDirectories = [];    return { type: 'get_claude_config_response', config };  }  private async handleSaveClaudeConfig(    config: any,    scope: 'user' | 'project' = 'user',    configType: 'settings' | 'mcp' = 'settings'  ): Promise<SaveClaudeConfigResponse> {    const cwd = this.workspaceService.getDefaultWorkspaceFolder()?.uri.fsPath ?? process.cwd();    const targetPath =      scope === 'project'        ? this.getProjectGuiConfigPath(cwd, configType)        : this.getUserGuiConfigPath(configType);    try {      await this.writeJsonFile(targetPath, config ?? {});      return { type: 'save_claude_config_response', success: true };    } catch (error) {      const msg = error instanceof Error ? error.message : String(error);      return { type: 'save_claude_config_response', success: false, error: msg };    }  }  private async handleGetMcpServers(): Promise<GetMcpServersResponse> {    const cwd = this.workspaceService.getDefaultWorkspaceFolder()?.uri.fsPath ?? process.cwd();    try {      const raw = await this.client.getMcpStatus(cwd);      const entries = Object.entries(raw ?? {});      const mcpServers = entries.map(([name, status]) => ({        name,        status:          typeof (status as any)?.status === 'string' ? String((status as any).status) : 'unknown'      }));      return { type: 'get_mcp_servers_response', mcpServers };    } catch (error) {      this.logService.warn(`[OpencodeAgentService] Failed to get MCP status: ${String(error)}`);      return { type: 'get_mcp_servers_response', mcpServers: [] };    }  }  private async handleGetAgents(): Promise<GetAgentsResponse> {    const cwd = this.workspaceService.getDefaultWorkspaceFolder()?.uri.fsPath ?? process.cwd();    const ohMy = await this.readOhMyConfig(cwd).catch(() => undefined);    const ohMyConfig = (ohMy as any)?.config as any;    const raw = await this.client.listAgents(cwd);    const agents: any[] = Array.isArray(raw) ? raw : (raw?.agents ?? []);    const mapped = agents.map((a) => {      const name = String(a?.name ?? a?.id ?? a?.slug ?? 'agent');      const description = String(a?.description ?? a?.prompt ?? '');      const category = String(a?.category ?? a?.type ?? 'OpenCode');      const configuredEnabled = ohMyConfig?.agents?.[name]?.enabled;      const enabled =        typeof configuredEnabled === 'boolean'          ? configuredEnabled          : typeof a?.enabled === 'boolean'            ? a.enabled            : typeof a?.disabled === 'boolean'              ? !a.disabled              : true;      return {        name,        description,        category,        path: name,        tools: Array.isArray(a?.tools) ? a.tools.map((t: any) => String(t)) : undefined,        model: a?.model ? String(a.model) : undefined,        enabled      };    });    return { type: 'get_agents_response', agents: mapped };  }  private async handleToggleAgent(    agentName: string,    enabled: boolean  ): Promise<ToggleAgentResponse> {    if (!agentName) {      return { type: 'toggle_agent_response', success: false, error: 'agentName 涓虹┖' };    }    const cwd = this.workspaceService.getDefaultWorkspaceFolder()?.uri.fsPath ?? process.cwd();    const targetPath = this.getProjectOhMyConfigPath(cwd);    try {      const existing = (await this.readJsonFile(targetPath).catch(() => undefined)) ?? {};      const next = { ...(existing ?? {}) } as any;      if (!next.agents || typeof next.agents !== 'object') next.agents = {};      const prev = next.agents[agentName];      next.agents[agentName] =        prev && typeof prev === 'object' ? { ...prev, enabled } : { enabled, replace_plan: true };      await this.writeJsonFile(targetPath, next);      return { type: 'toggle_agent_response', success: true };    } catch (error) {      const msg = error instanceof Error ? error.message : String(error);      return { type: 'toggle_agent_response', success: false, error: msg };    }  }  private async handleDeleteAgent(_agentPath: string): Promise<DeleteAgentResponse> {    return {      type: 'delete_agent_response',      success: false,      error:        'OpenCode Agents 鐢?server/鎻掍欢鎻愪緵锛孏UI 鏆備笉鏀寔鍒犻櫎锛堝彲鍦?oh-my-opencode.json 涓鐢級銆?    };  }  private async handleGetSkills(): Promise<GetSkillsResponse> {    const cwd = this.workspaceService.getDefaultWorkspaceFolder()?.uri.fsPath ?? process.cwd();    const ohMy = await this.readOhMyConfig(cwd).catch(() => undefined);    const ohMyConfig = (ohMy as any)?.config as any;    const disabled = new Set<string>(      Array.isArray(ohMyConfig?.disabled_hooks) ? ohMyConfig?.disabled_hooks : []    );    const skills = OH_MY_HOOKS.map((h) => ({      id: h.id,      name: h.id,      description: h.description,      version: undefined,      author: 'oh-my-opencode',      license: undefined,      path: h.id,      enabled: !disabled.has(h.id)    }));    return { type: 'get_skills_response', skills };  }  private async handleToggleSkill(skillId: string, enabled: boolean): Promise<ToggleSkillResponse> {    if (!skillId) {      return { type: 'toggle_skill_response', success: false, error: 'skillId 涓虹┖' };    }    const cwd = this.workspaceService.getDefaultWorkspaceFolder()?.uri.fsPath ?? process.cwd();    const targetPath = this.getProjectOhMyConfigPath(cwd);    try {      const existing = (await this.readJsonFile(targetPath).catch(() => undefined)) ?? {};      const next = { ...(existing ?? {}) } as any;      const current = new Set<string>(        Array.isArray(next.disabled_hooks) ? next.disabled_hooks : []      );      if (enabled) {        current.delete(skillId);      } else {        current.add(skillId);      }      next.disabled_hooks = Array.from(current.values()).sort((a, b) => a.localeCompare(b));      await this.writeJsonFile(targetPath, next);      return { type: 'toggle_skill_response', success: true };    } catch (error) {      const msg = error instanceof Error ? error.message : String(error);      return { type: 'toggle_skill_response', success: false, error: msg };    }  }  private async handleDeleteSkill(_skillPath: string): Promise<DeleteSkillResponse> {    return {      type: 'delete_skill_response',      success: false,      error: 'oh-my-opencode hooks 鏆備笉鏀寔鍒犻櫎锛堝彲绂佺敤/鍚敤锛夈€?    };  }  private async handleListFiles(pattern?: string): Promise<ListFilesResponse> {    const query = String(pattern ?? '').trim();    if (!query) {      return { type: 'list_files_response', files: [] };    }    const cwd = this.workspaceService.getDefaultWorkspaceFolder()?.uri.fsPath ?? process.cwd();    const exclude =      '{**/node_modules/**,**/.git/**,**/dist/**,**/build/**,**/.vscode/**,**/.idea/**}';    const normalized = query.replace(/\\\\/g, '/');    const glob = normalized === '*' || normalized === '**' ? '**/*' : `**/*${normalized}*`;    const uris = await vscode.workspace.findFiles(glob, exclude, 200);    const toRel = (uri: vscode.Uri) =>      vscode.workspace.asRelativePath(uri, false).replace(/\\\\/g, '/');    const files: Array<{ path: string; name: string; type: string; mtime?: number }> = [];    for (const uri of uris) {      if (uri.scheme !== 'file') continue;      const rel = toRel(uri);      const name = path.posix.basename(rel);      let mtime: number | undefined;      try {        const stat = await vscode.workspace.fs.stat(uri);        mtime = stat.mtime;      } catch {        // ignore      }      files.push({ path: rel, name, type: 'file', mtime });    }    const seenDirs = new Set<string>();    const dirs: Array<{ path: string; name: string; type: string; mtime?: number }> = [];    const addDir = (dir: string) => {      const d = dir.replace(/\\\\/g, '/').replace(/\/+$/, '');      if (!d || d === '.' || seenDirs.has(d)) return;      seenDirs.add(d);      dirs.push({ path: d, name: path.posix.basename(d), type: 'directory' });    };    if (normalized === '*' || normalized === '**') {      try {        const entries = await vscode.workspace.fs.readDirectory(vscode.Uri.file(cwd));        for (const [name, t] of entries) {          if (t !== vscode.FileType.Directory) continue;          if (name === 'node_modules' || name === '.git' || name === 'dist' || name === 'build')            continue;          addDir(name);        }      } catch {        // ignore      }    } else {      for (const f of files) {        const dir = path.posix.dirname(f.path);        if (dir && dir !== '.') addDir(dir);      }    }    const merged = [...dirs, ...files].slice(0, 200);    return { type: 'list_files_response', files: merged };  }  private async handleShowNotification(    req: ShowNotificationRequest  ): Promise<ShowNotificationResponse> {    const buttons = Array.isArray(req.buttons) ? req.buttons.map((b) => String(b)) : [];    let buttonValue: string | undefined;    if (req.severity === 'error') {      buttonValue = await vscode.window.showErrorMessage(req.message, ...buttons);    } else if (req.severity === 'warning') {      buttonValue = await vscode.window.showWarningMessage(req.message, ...buttons);    } else {      buttonValue = await vscode.window.showInformationMessage(req.message, ...buttons);    }    return { type: 'show_notification_response', buttonValue };  }  private async handleExec(command: string, params: string[]): Promise<ExecResponse> {    const cwd = this.workspaceService.getDefaultWorkspaceFolder()?.uri.fsPath ?? process.cwd();    return new Promise<ExecResponse>((resolve) => {      let stdout = '';      let stderr = '';      const proc = spawn(command, params, { cwd, shell: false, windowsHide: true });      proc.stdout?.on('data', (data: Buffer) => (stdout += data.toString()));      proc.stderr?.on('data', (data: Buffer) => (stderr += data.toString()));      proc.on('close', (code: number | null) => {        resolve({ type: 'exec_response', stdout, stderr, exitCode: code ?? 0 });      });      proc.on('error', (error: Error) => {        resolve({ type: 'exec_response', stdout: '', stderr: error.message, exitCode: 1 });      });    });  }  private async handleOpenContent(    content: string,    fileName: string,    editable: boolean  ): Promise<OpenContentResponse> {    if (!editable) {      const document = await vscode.workspace.openTextDocument({        content,        language: this.detectLanguage(fileName)      });      await vscode.window.showTextDocument(document, { preview: true });      return { type: 'open_content_response' };    }    const tempPath = await this.createTempFile(fileName || 'opencode.txt', content);    const tempUri = vscode.Uri.file(tempPath);    const document = await vscode.workspace.openTextDocument(tempUri);    await vscode.window.showTextDocument(document, { preview: false });    const updatedContent = await this.waitForDocumentEdits(document);    return { type: 'open_content_response', updatedContent };  }  private async handleOpenDiff(request: any): Promise<OpenDiffResponse> {    const cwd = this.workspaceService.getDefaultWorkspaceFolder()?.uri.fsPath ?? process.cwd();    const originalPath = this.resolveFilePath(String(request.originalFilePath ?? ''), cwd);    const fallbackNewPath = request.newFilePath      ? this.resolveFilePath(String(request.newFilePath), cwd)      : undefined;    const rightPath = await this.prepareDiffRightFile(      originalPath,      fallbackNewPath,      request.edits ?? []    );    const leftExists = await this.pathExists(originalPath);    const leftPath = leftExists      ? originalPath      : await this.createTempFile(          path.basename(String(request.originalFilePath ?? request.newFilePath ?? 'untitled')),          ''        );    await vscode.commands.executeCommand(      'vscode.diff',      vscode.Uri.file(leftPath),      vscode.Uri.file(rightPath),      `${path.basename(String(request.originalFilePath ?? request.newFilePath ?? rightPath))} (OpenCode)`,      { preview: true }    );    return { type: 'open_diff_response', newEdits: request.edits ?? [] };  }  private async handleNewConversationTab(): Promise<NewConversationTabResponse> {    try {      await vscode.commands.executeCommand('opencode.chatView.focus');    } catch (error) {      this.logService.warn(`[OpencodeAgentService] Failed to focus chat view: ${String(error)}`);    }    return { type: 'new_conversation_tab_response' };  }  private async handleOpenConfigFile(configType: string): Promise<void> {    const cwd = this.workspaceService.getDefaultWorkspaceFolder()?.uri.fsPath ?? process.cwd();    if (configType === 'oh-my-opencode') {      await this.openOhMyConfig();      return;    }    if (configType === 'opencode') {      const projectResolved = await this.resolveOpencodeConfigFilePath('opencode', 'project', cwd);      const userResolved = await this.resolveOpencodeConfigFilePath('opencode', 'user', cwd);      const target = (await this.pathExists(projectResolved.path))        ? projectResolved.path        : userResolved.path;      await vscode.workspace.fs.createDirectory(vscode.Uri.file(path.dirname(target)));      if (!(await this.pathExists(target))) {        await vscode.workspace.fs.writeFile(          vscode.Uri.file(target),          Buffer.from(this.defaultConfigTemplate('opencode'), 'utf8')        );      }      const doc = await vscode.workspace.openTextDocument(vscode.Uri.file(target));      await vscode.window.showTextDocument(doc, { preview: false });      return;    }    if (configType === 'auth') {      const resolved = await this.resolveOpencodeConfigFilePath('auth', 'user', cwd);      const target = resolved.path;      await vscode.workspace.fs.createDirectory(vscode.Uri.file(path.dirname(target)));      if (!(await this.pathExists(target))) {        await vscode.workspace.fs.writeFile(          vscode.Uri.file(target),          Buffer.from(this.defaultConfigTemplate('auth'), 'utf8')        );      }      const doc = await vscode.workspace.openTextDocument(vscode.Uri.file(target));      await vscode.window.showTextDocument(doc, { preview: false });      return;    }    const target =      configType === 'mcp'        ? this.getProjectGuiConfigPath(cwd, 'mcp')        : configType === 'project'          ? this.getProjectGuiConfigPath(cwd, 'settings')          : this.getUserGuiConfigPath('settings');    await vscode.workspace.fs.createDirectory(vscode.Uri.file(path.dirname(target)));    if (!(await this.pathExists(target))) {      await vscode.workspace.fs.writeFile(vscode.Uri.file(target), Buffer.from('{}', 'utf8'));    }    const doc = await vscode.workspace.openTextDocument(vscode.Uri.file(target));    await vscode.window.showTextDocument(doc, { preview: false });  }  private getOpencodeUserBaseDirs(): string[] {    const configDir = (      this.configService.getValue<string>('opencodeGui.configDir', '') ?? ''    ).trim();    const out: string[] = [];    if (configDir) {      out.push(configDir);      out.push(path.join(configDir, 'opencode'));    }    out.push(path.join(os.homedir(), '.config', 'opencode'));    // de-dupe while keeping order    const seen = new Set<string>();    return out.filter((d) => {      const key = process.platform === 'win32' ? d.toLowerCase() : d;      if (seen.has(key)) return false;      seen.add(key);      return true;    });  }  private async resolveOpencodeConfigFilePath(    configType: 'opencode' | 'oh-my-opencode' | 'auth',    requestedScope: 'user' | 'project' | undefined,    cwd: string  ): Promise<{ scope: 'user' | 'project'; path: string }> {    if (configType === 'auth') {      return {        scope: 'user',        path: path.join(os.homedir(), '.local', 'share', 'opencode', 'auth.json')      };    }    const scope = requestedScope === 'project' ? 'project' : 'user';    const filenames =      configType === 'opencode' ? ['opencode.jsonc', 'opencode.json'] : ['oh-my-opencode.json'];    if (scope === 'project') {      const base = path.join(cwd, '.opencode');      for (const name of filenames) {        const candidate = path.join(base, name);        if (await this.pathExists(candidate)) {          return { scope, path: candidate };        }      }      // Default to .json (not .jsonc) for new files.      const fallback = filenames[filenames.length - 1];      return { scope, path: path.join(base, fallback) };    }    const baseDirs = this.getOpencodeUserBaseDirs();    for (const base of baseDirs) {      for (const name of filenames) {        const candidate = path.join(base, name);        if (await this.pathExists(candidate)) {          return { scope, path: candidate };        }      }    }    const fallbackBase = baseDirs[baseDirs.length - 1] ?? path.join(os.homedir(), '.config', 'opencode');    const fallbackName = filenames[filenames.length - 1];    return { scope, path: path.join(fallbackBase, fallbackName) };  }  private defaultConfigTemplate(configType: 'opencode' | 'oh-my-opencode' | 'auth'): string {    if (configType === 'opencode') {      return '{\n  \"$schema\": \"https://opencode.ai/config.json\"\n}\n';    }    return '{\n}\n';  }  private async handleGetOpencodeConfigFile(    rawType: string,    rawScope: string  ): Promise<any> {    const cwd = this.workspaceService.getDefaultWorkspaceFolder()?.uri.fsPath ?? process.cwd();    const configType = (rawType || '').trim() as any;    if (configType !== 'opencode' && configType !== 'oh-my-opencode' && configType !== 'auth') {      return {        type: 'get_opencode_config_file_response',        configType: 'opencode',        scope: 'user',        path: '',        exists: false,        content: '',        error: `Unsupported configType: ${String(rawType)}`      };    }    const requestedScope = rawScope === 'project' ? 'project' : rawScope === 'user' ? 'user' : undefined;    const resolved = await this.resolveOpencodeConfigFilePath(configType, requestedScope, cwd);    try {      const exists = await this.pathExists(resolved.path);      const content = exists        ? Buffer.from(await vscode.workspace.fs.readFile(vscode.Uri.file(resolved.path))).toString(            'utf8'          )        : this.defaultConfigTemplate(configType);      return {        type: 'get_opencode_config_file_response',        configType,        scope: resolved.scope,        path: resolved.path,        exists,        content      };    } catch (error) {      const msg = error instanceof Error ? error.message : String(error);      this.logService.warn(`[OpencodeAgentService] get_opencode_config_file failed: ${msg}`);      return {        type: 'get_opencode_config_file_response',        configType,        scope: resolved.scope,        path: resolved.path,        exists: false,        content: this.defaultConfigTemplate(configType),        error: msg      };    }  }  private async handleSaveOpencodeConfigFile(    rawType: string,    rawScope: string,    content: string  ): Promise<any> {    const cwd = this.workspaceService.getDefaultWorkspaceFolder()?.uri.fsPath ?? process.cwd();    const configType = (rawType || '').trim() as any;    if (configType !== 'opencode' && configType !== 'oh-my-opencode' && configType !== 'auth') {      return {        type: 'save_opencode_config_file_response',        configType: 'opencode',        scope: 'user',        success: false,        error: `Unsupported configType: ${String(rawType)}`      };    }    const requestedScope = rawScope === 'project' ? 'project' : rawScope === 'user' ? 'user' : undefined;    const resolved = await this.resolveOpencodeConfigFilePath(configType, requestedScope, cwd);    try {      await vscode.workspace.fs.createDirectory(vscode.Uri.file(path.dirname(resolved.path)));      const text = typeof content === 'string' ? content : String(content ?? '');      await vscode.workspace.fs.writeFile(vscode.Uri.file(resolved.path), Buffer.from(text, 'utf8'));      return {        type: 'save_opencode_config_file_response',        configType,        scope: resolved.scope,        success: true,        path: resolved.path      };    } catch (error) {      const msg = error instanceof Error ? error.message : String(error);      // auth.json contains secrets; never include content in logs.      this.logService.warn(`[OpencodeAgentService] save_opencode_config_file failed: ${msg}`);      return {        type: 'save_opencode_config_file_response',        configType,        scope: resolved.scope,        success: false,        path: resolved.path,        error: msg      };    }  }  private async readAuthJsonFile(authPath: string): Promise<Record<string, unknown>> {    if (!(await this.pathExists(authPath))) return {};    const raw = Buffer.from(await vscode.workspace.fs.readFile(vscode.Uri.file(authPath))).toString(      'utf8'    );    const parsed = JSON.parse(raw);    if (!parsed || typeof parsed !== 'object' || Array.isArray(parsed)) return {};    return parsed as Record<string, unknown>;  }  private async handleGetOpencodeAuthStatus(providerIdRaw: string): Promise<any> {    const providerId = String(providerIdRaw ?? '').trim();    if (!providerId) {      return {        type: 'get_opencode_auth_status_response',        providerId: '',        exists: false,        error: 'providerId 涓虹┖'      };    }    const cwd = this.workspaceService.getDefaultWorkspaceFolder()?.uri.fsPath ?? process.cwd();    const resolved = await this.resolveOpencodeConfigFilePath('auth', 'user', cwd);    try {      const data = await this.readAuthJsonFile(resolved.path);      const entry = data[providerId];      if (!entry || typeof entry !== 'object' || Array.isArray(entry)) {        return { type: 'get_opencode_auth_status_response', providerId, exists: false };      }      const authType = String((entry as any)?.type ?? '').trim() as any;      const exists = authType === 'api' || authType === 'oauth' || authType === 'wellknown';      const hasApiKey =        authType === 'api' && typeof (entry as any)?.key === 'string' && String((entry as any).key).trim()          ? true          : false;      return {        type: 'get_opencode_auth_status_response',        providerId,        exists,        authType: exists ? authType : undefined,        hasApiKey: authType === 'api' ? hasApiKey : undefined      };    } catch (error) {      const msg = error instanceof Error ? error.message : String(error);      // auth.json contains secrets; never include content in logs.      this.logService.warn(`[OpencodeAgentService] get_opencode_auth_status failed: ${msg}`);      return {        type: 'get_opencode_auth_status_response',        providerId,        exists: false,        error: msg      };    }  }  private async handleSetOpencodeAuthApiKey(providerIdRaw: string, apiKeyRaw: string): Promise<any> {    const providerId = String(providerIdRaw ?? '').trim();    if (!providerId) {      return {        type: 'set_opencode_auth_api_key_response',        providerId: '',        success: false,        error: 'providerId 涓虹┖'      };    }    const cwd = this.workspaceService.getDefaultWorkspaceFolder()?.uri.fsPath ?? process.cwd();    const resolved = await this.resolveOpencodeConfigFilePath('auth', 'user', cwd);    const apiKey = String(apiKeyRaw ?? '').trim();    try {      await vscode.workspace.fs.createDirectory(vscode.Uri.file(path.dirname(resolved.path)));      let data: Record<string, unknown> = {};      try {        data = await this.readAuthJsonFile(resolved.path);      } catch {        data = {};      }      if (!apiKey) {        delete data[providerId];      } else {        data[providerId] = { type: 'api', key: apiKey };      }      const text = JSON.stringify(data, null, 2) + '\n';      await vscode.workspace.fs.writeFile(vscode.Uri.file(resolved.path), Buffer.from(text, 'utf8'));      void fs.chmod(resolved.path, 0o600).catch(() => undefined);      return { type: 'set_opencode_auth_api_key_response', providerId, success: true };    } catch (error) {      const msg = error instanceof Error ? error.message : String(error);      // auth.json contains secrets; never include content in logs.      this.logService.warn(`[OpencodeAgentService] set_opencode_auth_api_key failed: ${msg}`);      return {        type: 'set_opencode_auth_api_key_response',        providerId,        success: false,        error: msg      };    }  }  private async handleOpenInTerminal(): Promise<void> {    const opencodePath =      this.configService.getValue<string>('opencodeGui.opencodePath', 'opencode') ?? 'opencode';    const terminal = vscode.window.createTerminal('OpenCode');    terminal.show(true);    terminal.sendText(opencodePath, true);  }  private getUserGuiConfigDir(): string {    const configDir = (      this.configService.getValue<string>('opencodeGui.configDir', '') ?? ''    ).trim();    if (configDir) return configDir;    return path.join(os.homedir(), '.config', 'opencode');  }  private getUserGuiConfigPath(configType: 'settings' | 'mcp'): string {    const baseDir = this.getUserGuiConfigDir();    return path.join(      baseDir,      configType === 'mcp' ? 'opencode-gui-mcp.json' : 'opencode-gui-settings.json'    );  }  private getProjectGuiConfigPath(cwd: string, configType: 'settings' | 'mcp'): string {    const dir = path.join(cwd, '.opencode');    return path.join(      dir,      configType === 'mcp' ? 'opencode-gui-mcp.json' : 'opencode-gui-settings.json'    );  }  private getProjectOhMyConfigPath(cwd: string): string {    return path.join(cwd, '.opencode', 'oh-my-opencode.json');  }  private async readOhMyConfig(cwd: string): Promise<{ path: string; config: any } | undefined> {    const configDir = (      this.configService.getValue<string>('opencodeGui.configDir', '') ?? ''    ).trim();    const candidates = [      this.getProjectOhMyConfigPath(cwd),      configDir ? path.join(configDir, 'oh-my-opencode.json') : undefined,      configDir ? path.join(configDir, 'opencode', 'oh-my-opencode.json') : undefined,      path.join(os.homedir(), '.config', 'opencode', 'oh-my-opencode.json')    ].filter(Boolean) as string[];    for (const p of candidates) {      const json = await this.readJsonFile(p).catch(() => undefined);      if (json) return { path: p, config: json };    }    return undefined;  }  private async readJsonFile(filePath: string): Promise<any> {    const data = await vscode.workspace.fs.readFile(vscode.Uri.file(filePath));    const text = Buffer.from(data).toString('utf8');    return JSON.parse(text || '{}');  }  private async writeJsonFile(filePath: string, json: any): Promise<void> {    await vscode.workspace.fs.createDirectory(vscode.Uri.file(path.dirname(filePath)));    const text = JSON.stringify(json ?? {}, null, 2);    await vscode.workspace.fs.writeFile(vscode.Uri.file(filePath), Buffer.from(text, 'utf8'));  }  private resolveFilePath(filePath: string, cwd: string): string {    if (!filePath) return cwd;    return path.isAbsolute(filePath) ? filePath : path.join(cwd, filePath);  }  private async pathExists(filePath: string): Promise<boolean> {    try {      await vscode.workspace.fs.stat(vscode.Uri.file(filePath));      return true;    } catch {      return false;    }  }  private sanitizeFileName(fileName: string): string {    const fallback = fileName && fileName.trim() ? fileName.trim() : 'opencode.txt';    return fallback.replace(/[<>:"/\\|?*\x00-\x1F]/g, '_');  }  private detectLanguage(fileName?: string): string {    if (!fileName) return 'plaintext';    const ext = path.extname(fileName).toLowerCase();    switch (ext) {      case '.ts':      case '.tsx':        return 'typescript';      case '.js':      case '.jsx':        return 'javascript';      case '.json':        return 'json';      case '.py':        return 'python';      case '.java':        return 'java';      case '.go':        return 'go';      case '.rs':        return 'rust';      case '.md':        return 'markdown';      case '.sh':        return 'shellscript';      case '.css':        return 'css';      case '.html':      case '.htm':        return 'html';      default:        return 'plaintext';    }  }  private async createTempFile(fileName: string, content: string): Promise<string> {    const tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'opencode-'));    const sanitized = this.sanitizeFileName(fileName);    const filePath = path.join(tempDir, sanitized);    await fs.writeFile(filePath, content, 'utf8');    return filePath;  }  private async prepareDiffRightFile(    originalPath: string,    fallbackPath: string | undefined,    edits: Array<{ oldString: string; newString: string; replaceAll?: boolean }>  ): Promise<string> {    let baseContent = '';    if (await this.pathExists(originalPath)) {      baseContent = await fs.readFile(originalPath, 'utf8');    } else if (fallbackPath && (await this.pathExists(fallbackPath))) {      baseContent = await fs.readFile(fallbackPath, 'utf8');    }    let modified = baseContent;    for (const edit of edits) {      const oldString = edit.oldString ?? '';      const newString = edit.newString ?? '';      if (!oldString) {        modified += newString;        continue;      }      if (edit.replaceAll) {        modified = modified.split(oldString).join(newString);        continue;      }      const index = modified.indexOf(oldString);      if (index >= 0) {        modified = `${modified.slice(0, index)}${newString}${modified.slice(index + oldString.length)}`;      } else {        modified += newString;      }    }    const baseName = path.basename(fallbackPath || originalPath || 'opencode.diff');    const outputName = baseName.endsWith('.opencode') ? baseName : `${baseName}.opencode`;    return this.createTempFile(outputName, modified);  }  private async waitForDocumentEdits(document: vscode.TextDocument): Promise<string> {    let currentText = document.getText();    let resolved = false;    return new Promise<string>((resolve) => {      const disposables: vscode.Disposable[] = [];      const cleanup = () => {        if (resolved) return;        resolved = true;        disposables.forEach((d) => d.dispose());      };      disposables.push(        vscode.workspace.onDidChangeTextDocument((event) => {          if (event.document.uri.toString() === document.uri.toString()) {            currentText = event.document.getText();          }        })      );      disposables.push(        vscode.workspace.onDidSaveTextDocument((event) => {          if (event.uri.toString() === document.uri.toString()) {            currentText = event.getText();            cleanup();            resolve(currentText);          }        })      );      disposables.push(        vscode.workspace.onDidCloseTextDocument((event) => {          if (event.uri.toString() === document.uri.toString()) {            cleanup();            resolve(currentText);          }        })      );    });  }  private async handleGetCurrentSelection(): Promise<GetCurrentSelectionResponse> {    const editor = vscode.window.activeTextEditor;    if (!editor || editor.selection.isEmpty || editor.document.uri.scheme !== 'file') {      return { type: 'get_current_selection_response', selection: null };    }    const document = editor.document;    const selection = editor.selection;    return {      type: 'get_current_selection_response',      selection: {        filePath: document.uri.fsPath,        startLine: selection.start.line + 1,        endLine: selection.end.line + 1,        startColumn: selection.start.character,        endColumn: selection.end.character,        selectedText: document.getText(selection)      }    };  }  private async handleGetAssetUris(): Promise<GetAssetUrisResponse> {    const webview = this.webViewService.getWebView();    // Fallback: if we can't access a webview instance, return empty (UI will still work).    if (!webview) {      return { type: 'asset_uris_response', assetUris: {} };    }    const assets = {      clawd: {        light: path.join('resources', 'clawd.svg'),        dark: path.join('resources', 'clawd.svg')      },      'welcome-art': {        light: path.join('resources', 'welcome-art-light.svg'),        dark: path.join('resources', 'welcome-art-dark.svg')      }    } as const;    const extensionPath = this.webViewService.getExtensionPath();    const toWebviewUri = (relativePath: string) =>      webview.asWebviewUri(vscode.Uri.file(path.join(extensionPath, relativePath))).toString();    const assetUris = Object.fromEntries(      Object.entries(assets).map(([key, value]) => [        key,        { light: toWebviewUri(value.light), dark: toWebviewUri(value.dark) }      ])    );    return { type: 'asset_uris_response', assetUris };  }  private async handleListSessions(): Promise<ListSessionsResponse> {    const cwd = this.workspaceService.getDefaultWorkspaceFolder()?.uri.fsPath ?? process.cwd();    const raw = await this.client.listSessions(cwd);    const sessions: any[] = Array.isArray(raw) ? raw : (raw?.sessions ?? raw?.data ?? []);    const normalizeDir = (input: unknown): string => {      const raw = String(input ?? '').trim();      if (!raw) return '';      try {        return path.resolve(raw);      } catch {        return raw;      }    };    const cwdNormalized = normalizeDir(cwd);    const cwdKey = process.platform === 'win32' ? cwdNormalized.toLowerCase() : cwdNormalized;    const filtered = sessions.filter((s) => {      const dir = normalizeDir(s?.directory);      if (!dir) return true;      const dirKey = process.platform === 'win32' ? dir.toLowerCase() : dir;      return dirKey === cwdKey;    });    const mapped: Array<{      id: string;      parentId?: string;      lastModified: number;      messageCount: number;      summary: string;      worktree: undefined;      isCurrentWorkspace: true;    }> = [];    const sessionDirs: string[] = [];    const needsCount: number[] = [];    for (const s of filtered) {      const sessionId = String(s?.id ?? '');      if (!sessionId) continue;      const sessionDir = normalizeDir(s?.directory) || cwdNormalized;      const maybeCount =        s?.messageCount ??        s?.messagesCount ??        s?.message_count ??        s?.messages_count ??        s?.messages?.length ??        undefined;      const parsedCount = Number(maybeCount);      const hasCount = Number.isFinite(parsedCount);      mapped.push({        id: sessionId,        parentId: String(s?.parentID ?? s?.parentId ?? '').trim() || undefined,        lastModified: Number(s?.time?.updated ?? s?.time?.created ?? Date.now()),        messageCount: hasCount ? parsedCount : 0,        summary: String(s?.title ?? s?.id),        worktree: undefined,        isCurrentWorkspace: true      });      sessionDirs.push(sessionDir);      if (!hasCount) {        needsCount.push(mapped.length - 1);      }    }    // Fallback: compute message count by querying /session/:id/messages (may be expensive but fixes "0 messages" UX).    if (needsCount.length > 0) {      const concurrency = 4;      let cursor = 0;      const worker = async () => {        while (true) {          const idx = needsCount[cursor++];          if (idx === undefined) break;          const id = mapped[idx]?.id;          if (!id) continue;          try {            const sessionDir = sessionDirs[idx] ?? cwd;            const rawMessages = await this.client.listMessages(id, sessionDir);            const items: any[] = Array.isArray(rawMessages)              ? rawMessages              : (rawMessages?.messages ?? rawMessages?.data ?? []);            mapped[idx].messageCount = items.length;          } catch (error) {            this.logService.warn(              `[OpencodeAgentService] Failed to count messages for session ${id}: ${String(error)}`            );          }        }      };      await Promise.all(Array.from({ length: Math.min(concurrency, needsCount.length) }, worker));    }    return { type: 'list_sessions_response', sessions: mapped };  }  private async handleGetSession(sessionId: string): Promise<GetSessionResponse> {    const cwd = this.workspaceService.getDefaultWorkspaceFolder()?.uri.fsPath ?? process.cwd();    const raw = await this.client.listMessages(sessionId, cwd);    const items: Array<{ info: OpenCodeMessageInfo; parts: any[] }> = Array.isArray(raw)      ? raw      : (raw?.messages ?? raw?.data ?? []);    // Minimal history conversion: return empty for now if format is unexpected.    const events: any[] = [];    for (const item of items) {      const info = item?.info;      const parts = Array.isArray(item?.parts) ? item.parts : [];      const sid = (info as any)?.sessionID ?? (info as any)?.sessionId;      if (!info || !sid || !info.id) continue;      if (info.role === 'user') {        const text = parts          .filter((p) => p?.type === 'text')          .map((p) => String(p.text ?? ''))          .join('\n');        events.push({          type: 'user',          timestamp: Number(info.time?.created ?? Date.now()),          message: { role: 'user', content: [{ type: 'text', text }] }        });        continue;      }      if (info.role === 'assistant') {        const usage = this.toClaudeUsage((info as any)?.tokens);        // Tool parts as tool_use/tool_result        for (const p of parts) {          if (p?.type !== 'tool') continue;          const tp = p as OpenCodeToolPart;          const toolUseId = tp.callID || tp.id;          events.push({            type: 'assistant',            timestamp: Date.now(),            message: {              id: info.id,              role: 'assistant',              content: [                {                  type: 'tool_use',                  id: toolUseId,                  name: this.normalizeToolName(tp.tool),                  input: tp.state?.input ?? {}                }              ]            }          });          if (tp.state?.status === 'completed' || tp.state?.status === 'error') {            events.push({              type: 'user',              timestamp: Date.now(),              message: {                role: 'user',                content: [                  {                    type: 'tool_result',                    tool_use_id: toolUseId,                    content:                      tp.state?.status === 'completed'                        ? (tp.state.output ?? '')                        : (tp.state.error ?? ''),                    is_error: tp.state?.status === 'error'                  }                ]              }            });          }        }        // Reasoning as thinking        const thinking = parts          .filter((p) => p?.type === 'reasoning')          .map((p) => String(p.text ?? ''))          .join('');        if (thinking.trim()) {          events.push({            type: 'assistant',            timestamp: Date.now(),            message: { id: info.id, role: 'assistant', content: [{ type: 'thinking', thinking }] }          });        }        // Text as final output        const text = parts          .filter((p) => p?.type === 'text')          .map((p) => String(p.text ?? ''))          .join('');        if (text.trim()) {          events.push({            type: 'assistant',            timestamp: Date.now(),            message: { id: info.id, role: 'assistant', content: [{ type: 'text', text }] }          });        }        if (usage) {          events.push({            type: 'assistant',            timestamp: Number(info.time?.completed ?? info.time?.updated ?? info.time?.created ?? Date.now()),            message: { id: info.id, role: 'assistant', content: [], usage }          });        }      }    }    return { type: 'get_session_response', messages: events };  }  private async openFile(filePath: string, location?: any): Promise<void> {    const cwd = this.workspaceService.getDefaultWorkspaceFolder()?.uri.fsPath ?? process.cwd();    const absolutePath = path.isAbsolute(filePath) ? filePath : path.join(cwd, filePath);    const doc = await vscode.workspace.openTextDocument(vscode.Uri.file(absolutePath));    const editor = await vscode.window.showTextDocument(doc, { preview: false });    if (location) {      const startLine = Math.max((location.startLine ?? 1) - 1, 0);      const endLine = Math.max((location.endLine ?? location.startLine ?? 1) - 1, startLine);      const startColumn = Math.max(location.startColumn ?? 0, 0);      const endColumn = Math.max(location.endColumn ?? startColumn, startColumn);      const range = new vscode.Range(        new vscode.Position(startLine, startColumn),        new vscode.Position(endLine, endColumn)      );      editor.revealRange(range, vscode.TextEditorRevealType.InCenter);      editor.selection = new vscode.Selection(range.start, range.end);    }  }  private sendToChannel(channelId: string, event: any): void {    this.transport?.send({ type: 'io_message', channelId, message: event, done: false });  }  private readonly progressEventsByChannel = new Map<    string,    Array<{ ts: number; type: string; summary: string }>  >();  private pushProgressEvent(channelId: string, type: string, summary: string): void {    const trimmed = String(summary ?? '').trim();    if (!trimmed) return;    const arr = this.progressEventsByChannel.get(channelId) ?? [];    arr.push({ ts: Date.now(), type, summary: trimmed });    const MAX = 50;    if (arr.length > MAX) {      arr.splice(0, arr.length - MAX);    }    this.progressEventsByChannel.set(channelId, arr);  }  private getProgressSnapshot(channelId?: string) {    const cid = channelId ?? this.lastActiveChannelId;    if (!cid) {      return {        channelId: undefined,        sessionId: undefined,        running: false,        agent: undefined,        model: undefined,        lastEvents: [] as Array<{ ts: number; type: string; summary: string }>      };    }    const state = this.channels.get(cid);    const lastEvents = [...(this.progressEventsByChannel.get(cid) ?? [])];    const agent = state ? this.getEffectiveAgentName(state) : undefined;    const model = state ? this.getEffectiveModelSetting(state) : undefined;    return {      channelId: cid,      sessionId: state?.sessionId,      running: !!state?.running,      agent,      model,      lastEvents    };  }}