/**
 * InlineDiffService - æ–‡ä»¶ä¿®æ”¹æ‹¦æˆªæœåŠ¡ï¼ˆConflict Marker é£æ ¼ï¼‰
 *
 * æ ¸å¿ƒæ€è·¯ï¼šåƒ Git merge conflict ä¸€æ ·ï¼Œç›´æ¥åœ¨åŸæ–‡ä»¶ä¸­æ’å…¥ conflict markers
 *
 * æ ¼å¼ï¼š
 * ```
 * <<<<<<< Original [block-0]
 * æ—§å†…å®¹è¡Œ1
 * æ—§å†…å®¹è¡Œ2
 * =======
 * æ–°å†…å®¹è¡Œ1
 * æ–°å†…å®¹è¡Œ2
 * >>>>>>> Claude's Change
 * ```
 *
 * æ¯ä¸ªä¿®æ”¹å—å®Œå…¨ç‹¬ç«‹ï¼Œaccept/reject æ—¶åªéœ€è¦åˆ é™¤å¯¹åº”çš„æ ‡è®°å’Œä¸éœ€è¦çš„å†…å®¹
 */

import * as vscode from 'vscode';
import { createDecorator } from '../di/instantiation';
import { ILogService } from './logService';

export const IInlineDiffService = createDecorator<IInlineDiffService>('inlineDiffService');

export interface IInlineDiffService {
    readonly _serviceBrand: undefined;
    markFileForToolModification(filePath: string, channelId: string): void;
    setWorkModeProvider(provider: (channelId: string) => string | null): void;
}

/**
 * Conflict Blockï¼šä½¿ç”¨ conflict markers æ ‡è®°çš„ä¿®æ”¹å—
 */
interface ConflictBlock {
    id: string;  // å”¯ä¸€æ ‡è¯† (block-0, block-1, ...)
    startLine: number;  // `<<<<<<< Original [block-X]` æ‰€åœ¨è¡Œå·
    separatorLine: number;  // `=======` æ‰€åœ¨è¡Œå·
    endLine: number;  // `>>>>>>> Claude's Change` æ‰€åœ¨è¡Œå·
}

/**
 * CodeLens Providerï¼šåœ¨æ¯ä¸ª conflict marker ä¸Šæ–¹æ˜¾ç¤º"æ¥å—/æ‹’ç»"æŒ‰é’®
 */
class ConflictCodeLensProvider implements vscode.CodeLensProvider {
    private _onDidChangeCodeLenses = new vscode.EventEmitter<void>();
    public readonly onDidChangeCodeLenses = this._onDidChangeCodeLenses.event;

    constructor(
        private logService: ILogService
    ) {}

    refresh(): void {
        this._onDidChangeCodeLenses.fire();
    }

    provideCodeLenses(document: vscode.TextDocument): vscode.CodeLens[] {
        // å®æ—¶è§£ææ–‡æ¡£ä¸­çš„ conflict markers
        const blocks = this.parseConflictBlocks(document);
        if (blocks.length === 0) {
            return [];
        }

        const lenses: vscode.CodeLens[] = [];
        for (let i = 0; i < blocks.length; i++) {
            const block = blocks[i];
            const range = new vscode.Range(block.startLine, 0, block.startLine, 0);

            // "æ¥å—" æŒ‰é’®
            lenses.push(new vscode.CodeLens(range, {
                title: `$(check) æ¥å—`,
                command: 'claudix.acceptDiffBlock',
                arguments: [document.uri.fsPath, block.id]
            }));

            // "æ‹’ç»" æŒ‰é’®
            lenses.push(new vscode.CodeLens(range, {
                title: `$(x) æ‹’ç»`,
                command: 'claudix.rejectDiffBlock',
                arguments: [document.uri.fsPath, block.id]
            }));

            // ä¿®æ”¹è®¡æ•°å™¨
            lenses.push(new vscode.CodeLens(range, {
                title: `${i + 1} / ${blocks.length}`,
                command: ''
            }));
        }

        return lenses;
    }

    /**
     * è§£ææ–‡æ¡£ä¸­çš„ conflict markers
     */
    parseConflictBlocks(document: vscode.TextDocument): ConflictBlock[] {
        const blocks: ConflictBlock[] = [];
        const lines = document.getText().split('\n');

        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            const match = line.match(/^<<<<<<< Original \[(block-\d+)\]$/);
            if (match) {
                const blockId = match[1];
                // æ‰¾åˆ°å¯¹åº”çš„ ======= å’Œ >>>>>>>
                let separatorLine = -1;
                let endLine = -1;

                for (let j = i + 1; j < lines.length; j++) {
                    if (lines[j] === '=======') {
                        separatorLine = j;
                    } else if (lines[j] === ">>>>>>> Claude's Change") {
                        endLine = j;
                        break;
                    }
                }

                if (separatorLine !== -1 && endLine !== -1) {
                    blocks.push({
                        id: blockId,
                        startLine: i,
                        separatorLine,
                        endLine
                    });
                }
            }
        }

        return blocks;
    }
}

export class InlineDiffService implements IInlineDiffService {
    readonly _serviceBrand: undefined;

    private disposables: vscode.Disposable[] = [];
    private documentContentCache = new Map<string, string>();  // ç¼“å­˜æ–‡æ¡£å†…å®¹
    private isApplyingChange = false;  // æ ‡è®°ï¼šæ­£åœ¨åº”ç”¨ä¿®æ”¹

    // ===== ä»¥ä¸‹æ˜¯inline diffåŠŸèƒ½ï¼Œæš‚æ—¶æ³¨é‡Š =====
    // private originalContentCache = new Map<string, string>();  // ç¼“å­˜çœŸå®åŸå§‹å†…å®¹ï¼ˆä¸åŒ…å«markersï¼‰
    // private conflictStartDecoration: vscode.TextEditorDecorationType;
    // private originalContentDecoration: vscode.TextEditorDecorationType;
    // private separatorDecoration: vscode.TextEditorDecorationType;
    // private modifiedContentDecoration: vscode.TextEditorDecorationType;
    // private conflictEndDecoration: vscode.TextEditorDecorationType;
    // private codeLensProvider: ConflictCodeLensProvider;
    // ===== inline diff ç»“æŸ =====

    // è®°å½•å³å°†è¢«å·¥å…·ä¿®æ”¹çš„æ–‡ä»¶ï¼ˆæ–‡ä»¶è·¯å¾„ -> channelIdï¼‰
    private pendingToolModifications = new Map<string, string>();
    private cleanupTimers = new Map<string, NodeJS.Timeout>();

    // WorkMode æä¾›è€…ï¼ˆæ ¹æ® channelId è·å–å¯¹åº”çš„ workModeï¼‰
    private workModeProvider?: (channelId: string) => string | null;

    constructor(
        @ILogService private readonly logService: ILogService
    ) {
        this.logService.warn('ğŸ”§ [InlineDiffService] æ„é€ å‡½æ•°è¢«è°ƒç”¨');

        // ===== ä»¥ä¸‹è£…é¥°å™¨å’ŒCodeLensæ³¨å†Œå·²æ³¨é‡Šï¼Œinline diffåŠŸèƒ½æš‚æ—¶ç¦ç”¨ =====
        /*
        // åˆå§‹åŒ–è£…é¥°å™¨ç±»å‹
        this.conflictStartDecoration = vscode.window.createTextEditorDecorationType({
            backgroundColor: 'rgba(128, 128, 128, 0.2)',
            isWholeLine: true
        });

        this.originalContentDecoration = vscode.window.createTextEditorDecorationType({
            backgroundColor: 'rgba(255, 0, 0, 0.2)',
            isWholeLine: true,
            before: {
                contentText: '-',
                color: 'rgba(255, 0, 0, 0.8)',
                margin: '0 10px 0 0',
                fontWeight: 'bold'
            }
        });

        this.separatorDecoration = vscode.window.createTextEditorDecorationType({
            backgroundColor: 'rgba(128, 128, 128, 0.2)',
            isWholeLine: true
        });

        this.modifiedContentDecoration = vscode.window.createTextEditorDecorationType({
            backgroundColor: 'rgba(0, 255, 0, 0.2)',
            isWholeLine: true,
            before: {
                contentText: '+',
                color: 'rgba(0, 255, 0, 0.8)',
                margin: '0 10px 0 0',
                fontWeight: 'bold'
            }
        });

        this.conflictEndDecoration = vscode.window.createTextEditorDecorationType({
            backgroundColor: 'rgba(128, 128, 128, 0.2)',
            isWholeLine: true
        });

        // åˆå§‹åŒ– CodeLens Provider
        this.codeLensProvider = new ConflictCodeLensProvider(this.logService);

        // æ³¨å†Œ CodeLens Provider
        this.disposables.push(
            vscode.languages.registerCodeLensProvider({ scheme: 'file' }, this.codeLensProvider)
        );

        // æ³¨å†Œå‘½ä»¤
        this.disposables.push(
            vscode.commands.registerCommand('claudix.acceptDiffBlock', (filePath: string, blockId: string) => {
                this.acceptBlock(filePath, blockId);
            })
        );

        this.disposables.push(
            vscode.commands.registerCommand('claudix.rejectDiffBlock', (filePath: string, blockId: string) => {
                this.rejectBlock(filePath, blockId);
            })
        );

        this.disposables.push(
            vscode.commands.registerCommand('claudix.acceptAllDiffs', () => {
                const editor = vscode.window.activeTextEditor;
                if (editor) {
                    this.acceptAllBlocks(editor.document.uri.fsPath);
                }
            })
        );

        this.disposables.push(
            vscode.commands.registerCommand('claudix.rejectAllDiffs', () => {
                const editor = vscode.window.activeTextEditor;
                if (editor) {
                    this.rejectAllBlocks(editor.document.uri.fsPath);
                }
            })
        );
        */
        // ===== inline diff æ³¨å†Œç»“æŸ =====

        // ===== æ–‡ä»¶ç›‘å¬åŠŸèƒ½æš‚æ—¶ç¦ç”¨ =====
        // this.startMonitoringFileChanges();

        this.logService.warn('âœ… [InlineDiffService] æ„é€ å‡½æ•°æ‰§è¡Œå®Œæˆï¼ˆæ‰€æœ‰åŠŸèƒ½å·²æ³¨é‡Šï¼‰');
    }

    /**
     * è®¾ç½® WorkMode æä¾›è€…ï¼ˆç”± ClaudeAgentService è°ƒç”¨ï¼Œé¿å…å¾ªç¯ä¾èµ–ï¼‰
     */
    setWorkModeProvider(provider: (channelId: string) => string | null): void {
        this.workModeProvider = provider;
        this.logService.warn('âœ… [InlineDiffService] WorkMode æä¾›è€…å·²è®¾ç½®');
    }

    /**
     * è·å–æŒ‡å®š channel çš„å·¥ä½œæ¨¡å¼
     */
    private getChannelWorkMode(channelId: string): string | null {
        return this.workModeProvider ? this.workModeProvider(channelId) : null;
    }

    /**
     * æ ‡è®°æ–‡ä»¶å³å°†è¢«å·¥å…·ä¿®æ”¹ï¼ˆç”± ClaudeAgentService è°ƒç”¨ï¼‰
     */
    markFileForToolModification(filePath: string, channelId: string): void {
        // è§„èŒƒåŒ–è·¯å¾„ï¼šå°†ç›¸å¯¹è·¯å¾„è½¬æ¢ä¸ºç»å¯¹è·¯å¾„
        let normalizedPath = filePath.replace(/\//g, '\\');

        // å¦‚æœæ˜¯ç›¸å¯¹è·¯å¾„ï¼Œè½¬æ¢ä¸ºç»å¯¹è·¯å¾„
        if (!normalizedPath.match(/^[a-zA-Z]:\\/)) {
            const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
            if (workspaceFolder) {
                const path = require('path');
                normalizedPath = path.join(workspaceFolder.uri.fsPath, normalizedPath).replace(/\//g, '\\');
                this.logService.warn(`   -> è½¬æ¢ç›¸å¯¹è·¯å¾„ä¸ºç»å¯¹è·¯å¾„: ${normalizedPath}`);
            }
        }

        this.logService.warn(`ğŸ”– [ToolTracker] æ ‡è®°æ–‡ä»¶å°†è¢«å·¥å…·ä¿®æ”¹: ${normalizedPath.substring(normalizedPath.lastIndexOf('\\') + 1)} (channel: ${channelId})`);
        this.pendingToolModifications.set(normalizedPath, channelId);

        const oldTimer = this.cleanupTimers.get(normalizedPath);
        if (oldTimer) {
            clearTimeout(oldTimer);
        }

        const timer = setTimeout(() => {
            this.pendingToolModifications.delete(normalizedPath);
            this.cleanupTimers.delete(normalizedPath);
            this.logService.warn(`â° [ToolTracker] è‡ªåŠ¨æ¸…é™¤æ ‡è®°: ${normalizedPath.substring(normalizedPath.lastIndexOf('\\') + 1)}`);
        }, 30000);  // 30ç§’è¶…æ—¶

        this.cleanupTimers.set(normalizedPath, timer);
    }

    /**
     * å¼€å§‹ç›‘å¬æ–‡ä»¶å˜åŒ–
     * ===== æ­¤åŠŸèƒ½å·²å…¨éƒ¨æ³¨é‡Šï¼Œæš‚æ—¶ç¦ç”¨ =====
     */
    /*
    private startMonitoringFileChanges(): void {
        this.logService.warn('ğŸ¯ [FileMonitor] å¼€å§‹ç›‘å¬æ–‡ä»¶å˜åŒ–');

        vscode.workspace.textDocuments.forEach(doc => {
            this.documentContentCache.set(doc.uri.fsPath, doc.getText());
        });

        this.disposables.push(
            vscode.workspace.onDidChangeTextDocument(async (event) => {
                if (this.isApplyingChange) {
                    return;
                }

                const doc = event.document;
                const filePath = doc.uri.fsPath;

                if (doc.uri.scheme !== 'file') {
                    return;
                }

                const oldContent = this.documentContentCache.get(filePath);
                if (!oldContent) {
                    this.documentContentCache.set(filePath, doc.getText());
                    return;
                }

                const newContent = doc.getText();
                const markedChannelId = this.pendingToolModifications.get(filePath);
                const isMarkedForToolModification = markedChannelId !== undefined;

                this.logService.warn(`ğŸ“ [FileMonitor] æ–‡æ¡£å˜åŒ–: ${filePath.substring(filePath.lastIndexOf('\\') + 1)}`);
                this.logService.warn(`  -> å·¥å…·æ ‡è®°: ${isMarkedForToolModification} (channel: ${markedChannelId || 'none'})`);

                if (isMarkedForToolModification && markedChannelId) {
                    this.pendingToolModifications.delete(filePath);
                    const timer = this.cleanupTimers.get(filePath);
                    if (timer) {
                        clearTimeout(timer);
                        this.cleanupTimers.delete(filePath);
                    }

                    const workMode = this.getChannelWorkMode(markedChannelId);
                    this.logService.warn(`  -> Channel ${markedChannelId} çš„å·¥ä½œæ¨¡å¼: ${workMode || 'null'}`);

                    // æš‚æ—¶æ³¨é‡Š inline diff åŠŸèƒ½ï¼Œç›´æ¥è‡ªåŠ¨åº”ç”¨æ‰€æœ‰ä¿®æ”¹
                    // TODO: ä»¥åéœ€è¦æ—¶å†å¯ç”¨ inline diff
                    // if (workMode === 'agent') {
                    //     // Agent æ¨¡å¼ï¼šè‡ªåŠ¨åº”ç”¨ä¿®æ”¹
                    //     this.logService.warn(`âœ… [FileMonitor] Agent æ¨¡å¼ï¼Œè‡ªåŠ¨åº”ç”¨ä¿®æ”¹`);
                    //     this.documentContentCache.set(filePath, newContent);
                    //     const fileName = filePath.substring(filePath.lastIndexOf('\\') + 1);
                    //     vscode.window.showInformationMessage(`âœ… å·²è‡ªåŠ¨åº”ç”¨ Claude ä¿®æ”¹: ${fileName}`);
                    // } else {
                    //     // Default æ¨¡å¼ï¼šæ˜¾ç¤º conflict markers
                    //     this.logService.warn(`âš ï¸ [FileMonitor] ${workMode || 'Default'} æ¨¡å¼ï¼Œæ˜¾ç¤º conflict markers`);
                    //
                    //     // å¦‚æœæ˜¯ç¬¬ä¸€æ¬¡ä¿®æ”¹ï¼Œä¿å­˜çœŸå®åŸå§‹å†…å®¹
                    //     if (!this.originalContentCache.has(filePath)) {
                    //         this.originalContentCache.set(filePath, oldContent);
                    //     }
                    //
                    //     // ä½¿ç”¨çœŸå®åŸå§‹å†…å®¹ï¼ˆä¸åŒ…å«markersï¼‰è®¡ç®—diff
                    //     const realOriginalContent = this.originalContentCache.get(filePath) || oldContent;
                    //     await this.insertConflictMarkers(filePath, realOriginalContent, newContent);
                    // }

                    // æ‰€æœ‰æ¨¡å¼éƒ½è‡ªåŠ¨åº”ç”¨ä¿®æ”¹
                    this.logService.warn(`âœ… [FileMonitor] è‡ªåŠ¨åº”ç”¨ä¿®æ”¹`);
                    this.documentContentCache.set(filePath, newContent);
                    const fileName = filePath.substring(filePath.lastIndexOf('\\') + 1);
                    vscode.window.showInformationMessage(`âœ… å·²è‡ªåŠ¨åº”ç”¨ Claude ä¿®æ”¹: ${fileName}`);
                } else {
                    // ç”¨æˆ·æ‰‹åŠ¨ä¿®æ”¹ï¼Œæ›´æ–°ç¼“å­˜
                    this.documentContentCache.set(filePath, newContent);
                }
            })
        );

        // ===== ç¼–è¾‘å™¨åˆ‡æ¢ç›‘å¬å·²æ³¨é‡Šï¼Œinline diffåŠŸèƒ½æš‚æ—¶ç¦ç”¨ =====
        // this.disposables.push(
        //     vscode.window.onDidChangeActiveTextEditor(editor => {
        //         if (editor) {
        //             this.updateDecorations(editor);
        //         }
        //     })
        // );

        this.logService.warn('âœ… [FileMonitor] æ–‡ä»¶ç›‘å¬å·²å¯åŠ¨');
    }
    */
    // ===== æ–‡ä»¶ç›‘å¬åŠŸèƒ½ç»“æŸ =====

    /**
     * æ’å…¥ conflict markers åˆ°æ–‡æ¡£
     * ===== æ­¤åŠŸèƒ½å·²å…¨éƒ¨æ³¨é‡Šï¼Œæš‚æ—¶ç¦ç”¨ =====
     */
    /*
    private async insertConflictMarkers(filePath: string, oldContent: string, newContent: string): Promise<void> {
        const fileName = filePath.substring(filePath.lastIndexOf('\\') + 1);
        this.logService.warn(`ğŸ¨ [ConflictMarker] æ’å…¥ conflict markers: ${fileName}`);

        try {
            // æ’¤é”€ä¿®æ”¹
            await this.undoChanges(filePath, oldContent);

            // è®¡ç®— diff
            const diffBlocks = this.calculateDiff(oldContent, newContent);
            this.logService.warn(`  -> æ‰¾åˆ° ${diffBlocks.length} ä¸ªä¿®æ”¹å—`);

            if (diffBlocks.length === 0) {
                this.logService.warn(`  -> æ— å·®å¼‚ï¼Œè·³è¿‡`);
                return;
            }

            // æ„å»ºå¸¦ conflict markers çš„å†…å®¹
            const contentWithMarkers = this.buildContentWithMarkers(oldContent, newContent, diffBlocks);

            // åº”ç”¨åˆ°æ–‡æ¡£
            this.isApplyingChange = true;
            try {
                const doc = await vscode.workspace.openTextDocument(vscode.Uri.file(filePath));
                const edit = new vscode.WorkspaceEdit();
                const fullRange = new vscode.Range(
                    doc.positionAt(0),
                    doc.positionAt(doc.getText().length)
                );
                edit.replace(doc.uri, fullRange, contentWithMarkers);
                await vscode.workspace.applyEdit(edit);

                // æ›´æ–°ç¼“å­˜
                this.documentContentCache.set(filePath, contentWithMarkers);

                // æ˜¾ç¤ºæ–‡æ¡£å¹¶æ›´æ–°è£…é¥°
                const editor = await vscode.window.showTextDocument(doc);
                this.updateDecorations(editor);

                // åˆ·æ–° CodeLens
                this.codeLensProvider.refresh();

                vscode.window.setStatusBarMessage(
                    `âš¡ Claude åšäº† ${diffBlocks.length} å¤„ä¿®æ”¹ - ç‚¹å‡»ä¸Šæ–¹æŒ‰é’®æ¥å—/æ‹’ç»`,
                    15000
                );

                this.logService.warn(`âœ… [ConflictMarker] å·²æ’å…¥ ${diffBlocks.length} ä¸ª conflict markers`);
            } finally {
                this.isApplyingChange = false;
            }
        } catch (error) {
            this.logService.error(`âŒ [ConflictMarker] æ’å…¥å¤±è´¥: ${error}`);
            vscode.window.showErrorMessage(`æ’å…¥ conflict markers å¤±è´¥: ${error}`);
        }
    }

    // ===== ä»¥ä¸‹æ‰€æœ‰ inline diff ç›¸å…³æ–¹æ³•å·²å…¨éƒ¨æ³¨é‡Š =====
    /*
    private async undoChanges(filePath: string, oldContent: string): Promise<void> {
        this.isApplyingChange = true;
        try {
            const doc = await vscode.workspace.openTextDocument(vscode.Uri.file(filePath));
            const edit = new vscode.WorkspaceEdit();
            const fullRange = new vscode.Range(
                doc.positionAt(0),
                doc.positionAt(doc.getText().length)
            );
            edit.replace(doc.uri, fullRange, oldContent);
            await vscode.workspace.applyEdit(edit);
            this.logService.warn('â†©ï¸ [FileMonitor] å·²æ’¤é”€ä¿®æ”¹');
        } finally {
            this.isApplyingChange = false;
        }
    }

    /**
     * è®¡ç®— diffï¼ˆç®€å•çš„é€è¡Œå¯¹æ¯”ï¼‰
     */
    private calculateDiff(oldContent: string, newContent: string): { startLine: number; deletedLines: string[]; addedLines: string[]; }[] {
        const oldLines = oldContent.split('\n');
        const newLines = newContent.split('\n');
        const blocks: { startLine: number; deletedLines: string[]; addedLines: string[]; }[] = [];

        let i = 0;
        const maxLines = Math.max(oldLines.length, newLines.length);

        while (i < maxLines) {
            // æ‰¾åˆ°ç¬¬ä¸€ä¸ªä¸åŒçš„ä½ç½®
            while (i < oldLines.length && i < newLines.length && oldLines[i] === newLines[i]) {
                i++;
            }

            if (i >= maxLines) {
                break;
            }

            // æ”¶é›†è¿ç»­çš„ä¸åŒè¡Œ
            const deletedLines: string[] = [];
            const addedLines: string[] = [];
            const blockStart = i;

            while (i < maxLines && (i >= oldLines.length || i >= newLines.length || oldLines[i] !== newLines[i])) {
                if (i < oldLines.length) {
                    deletedLines.push(oldLines[i]);
                }
                if (i < newLines.length) {
                    addedLines.push(newLines[i]);
                }
                i++;

                // æœ€å¤š 50 è¡Œä¸€ä¸ªå—
                if (i - blockStart >= 50) {
                    break;
                }
            }

            if (deletedLines.length > 0 || addedLines.length > 0) {
                blocks.push({
                    startLine: blockStart,
                    deletedLines,
                    addedLines
                });
            }
        }

        return blocks;
    }

    /**
     * æ„å»ºå¸¦ conflict markers çš„å†…å®¹
     */
    private buildContentWithMarkers(
        oldContent: string,
        newContent: string,
        diffBlocks: { startLine: number; deletedLines: string[]; addedLines: string[]; }[]
    ): string {
        const oldLines = oldContent.split('\n');
        const result: string[] = [];
        let lastLine = 0;

        for (let i = 0; i < diffBlocks.length; i++) {
            const block = diffBlocks[i];

            // æ·»åŠ æœªä¿®æ”¹çš„è¡Œ
            for (let j = lastLine; j < block.startLine; j++) {
                result.push(oldLines[j]);
            }

            // æ·»åŠ  conflict markers
            result.push(`<<<<<<< Original [block-${i}]`);
            for (const line of block.deletedLines) {
                result.push(line);
            }
            result.push('=======');
            for (const line of block.addedLines) {
                result.push(line);
            }
            result.push(">>>>>>> Claude's Change");

            lastLine = block.startLine + block.deletedLines.length;
        }

        // æ·»åŠ å‰©ä½™çš„æœªä¿®æ”¹è¡Œ
        for (let i = lastLine; i < oldLines.length; i++) {
            result.push(oldLines[i]);
        }

        return result.join('\n');
    }

    /**
     * æ›´æ–°è£…é¥°ï¼ˆçº¢è‰²/ç»¿è‰²æ ‡è®°ï¼‰
     */
    private updateDecorations(editor: vscode.TextEditor): void {
        const blocks = this.codeLensProvider.parseConflictBlocks(editor.document);
        if (blocks.length === 0) {
            // æ¸…é™¤æ‰€æœ‰è£…é¥°
            editor.setDecorations(this.conflictStartDecoration, []);
            editor.setDecorations(this.originalContentDecoration, []);
            editor.setDecorations(this.separatorDecoration, []);
            editor.setDecorations(this.modifiedContentDecoration, []);
            editor.setDecorations(this.conflictEndDecoration, []);
            return;
        }

        const startRanges: vscode.Range[] = [];
        const originalRanges: vscode.Range[] = [];
        const separatorRanges: vscode.Range[] = [];
        const modifiedRanges: vscode.Range[] = [];
        const endRanges: vscode.Range[] = [];

        for (const block of blocks) {
            // <<<<<<< è¡Œ
            startRanges.push(new vscode.Range(block.startLine, 0, block.startLine, editor.document.lineAt(block.startLine).text.length));

            // æ—§å†…å®¹ï¼ˆçº¢è‰²ï¼‰
            for (let i = block.startLine + 1; i < block.separatorLine; i++) {
                originalRanges.push(new vscode.Range(i, 0, i, editor.document.lineAt(i).text.length));
            }

            // ======= è¡Œ
            separatorRanges.push(new vscode.Range(block.separatorLine, 0, block.separatorLine, editor.document.lineAt(block.separatorLine).text.length));

            // æ–°å†…å®¹ï¼ˆç»¿è‰²ï¼‰
            for (let i = block.separatorLine + 1; i < block.endLine; i++) {
                modifiedRanges.push(new vscode.Range(i, 0, i, editor.document.lineAt(i).text.length));
            }

            // >>>>>>> è¡Œ
            endRanges.push(new vscode.Range(block.endLine, 0, block.endLine, editor.document.lineAt(block.endLine).text.length));
        }

        editor.setDecorations(this.conflictStartDecoration, startRanges);
        editor.setDecorations(this.originalContentDecoration, originalRanges);
        editor.setDecorations(this.separatorDecoration, separatorRanges);
        editor.setDecorations(this.modifiedContentDecoration, modifiedRanges);
        editor.setDecorations(this.conflictEndDecoration, endRanges);
    }

    /**
     * æ¥å—å•ä¸ª block
     */
    private async acceptBlock(filePath: string, blockId: string): Promise<void> {
        this.logService.warn(`âœ… [AcceptBlock] æ¥å—ä¿®æ”¹å—: ${blockId}`);

        this.isApplyingChange = true;
        try {
            const doc = await vscode.workspace.openTextDocument(vscode.Uri.file(filePath));
            const blocks = this.codeLensProvider.parseConflictBlocks(doc);
            const block = blocks.find(b => b.id === blockId);

            if (!block) {
                this.logService.warn(`âš ï¸ [AcceptBlock] æœªæ‰¾åˆ° block: ${blockId}`);
                return;
            }

            // åˆ é™¤æ•´ä¸ª conflict blockï¼Œåªä¿ç•™æ–°å†…å®¹ï¼ˆç»¿è‰²éƒ¨åˆ†ï¼‰
            const lines = doc.getText().split('\n');
            const newLines = [
                ...lines.slice(0, block.startLine),
                ...lines.slice(block.separatorLine + 1, block.endLine),
                ...lines.slice(block.endLine + 1)
            ];

            const edit = new vscode.WorkspaceEdit();
            const fullRange = new vscode.Range(
                doc.positionAt(0),
                doc.positionAt(doc.getText().length)
            );
            edit.replace(doc.uri, fullRange, newLines.join('\n'));
            await vscode.workspace.applyEdit(edit);

            // æ›´æ–°ç¼“å­˜
            this.documentContentCache.set(filePath, newLines.join('\n'));

            // åˆ·æ–°è£…é¥°å’Œ CodeLens
            const editor = vscode.window.visibleTextEditors.find(e => e.document.uri.fsPath === filePath);
            if (editor) {
                this.updateDecorations(editor);
            }
            this.codeLensProvider.refresh();

            // æ£€æŸ¥æ˜¯å¦è¿˜æœ‰å…¶ä»– conflicts
            const remainingBlocks = this.codeLensProvider.parseConflictBlocks(await vscode.workspace.openTextDocument(vscode.Uri.file(filePath)));
            if (remainingBlocks.length === 0) {
                // æ‰€æœ‰ conflicts å·²è§£å†³ï¼Œæ¸…ç†ç¼“å­˜å¹¶ä¿å­˜æ–‡ä»¶
                this.originalContentCache.delete(filePath);
                await doc.save();
                vscode.window.setStatusBarMessage(`âœ… æ‰€æœ‰ä¿®æ”¹å·²å¤„ç†å®Œæˆ`, 5000);
            } else {
                vscode.window.setStatusBarMessage(`âœ… å·²æ¥å—ä¿®æ”¹ï¼Œå‰©ä½™ ${remainingBlocks.length} å¤„`, 3000);
            }

            this.logService.warn(`âœ… [AcceptBlock] å·²æ¥å— ${blockId}`);
        } finally {
            this.isApplyingChange = false;
        }
    }

    /**
     * æ‹’ç»å•ä¸ª block
     */
    private async rejectBlock(filePath: string, blockId: string): Promise<void> {
        this.logService.warn(`âŒ [RejectBlock] æ‹’ç»ä¿®æ”¹å—: ${blockId}`);

        this.isApplyingChange = true;
        try {
            const doc = await vscode.workspace.openTextDocument(vscode.Uri.file(filePath));
            const blocks = this.codeLensProvider.parseConflictBlocks(doc);
            const block = blocks.find(b => b.id === blockId);

            if (!block) {
                this.logService.warn(`âš ï¸ [RejectBlock] æœªæ‰¾åˆ° block: ${blockId}`);
                return;
            }

            // åˆ é™¤æ•´ä¸ª conflict blockï¼Œåªä¿ç•™æ—§å†…å®¹ï¼ˆçº¢è‰²éƒ¨åˆ†ï¼‰
            const lines = doc.getText().split('\n');
            const newLines = [
                ...lines.slice(0, block.startLine),
                ...lines.slice(block.startLine + 1, block.separatorLine),
                ...lines.slice(block.endLine + 1)
            ];

            const edit = new vscode.WorkspaceEdit();
            const fullRange = new vscode.Range(
                doc.positionAt(0),
                doc.positionAt(doc.getText().length)
            );
            edit.replace(doc.uri, fullRange, newLines.join('\n'));
            await vscode.workspace.applyEdit(edit);

            // æ›´æ–°ç¼“å­˜
            this.documentContentCache.set(filePath, newLines.join('\n'));

            // åˆ·æ–°è£…é¥°å’Œ CodeLens
            const editor = vscode.window.visibleTextEditors.find(e => e.document.uri.fsPath === filePath);
            if (editor) {
                this.updateDecorations(editor);
            }
            this.codeLensProvider.refresh();

            // æ£€æŸ¥æ˜¯å¦è¿˜æœ‰å…¶ä»– conflicts
            const remainingBlocks = this.codeLensProvider.parseConflictBlocks(await vscode.workspace.openTextDocument(vscode.Uri.file(filePath)));
            if (remainingBlocks.length === 0) {
                // æ‰€æœ‰ conflicts å·²è§£å†³ï¼Œæ¸…ç†ç¼“å­˜å¹¶ä¿å­˜æ–‡ä»¶
                this.originalContentCache.delete(filePath);
                await doc.save();
                vscode.window.setStatusBarMessage(`âœ… æ‰€æœ‰ä¿®æ”¹å·²å¤„ç†å®Œæˆ`, 5000);
            } else {
                vscode.window.setStatusBarMessage(`âŒ å·²æ‹’ç»ä¿®æ”¹ï¼Œå‰©ä½™ ${remainingBlocks.length} å¤„`, 3000);
            }

            this.logService.warn(`âŒ [RejectBlock] å·²æ‹’ç» ${blockId}`);
        } finally {
            this.isApplyingChange = false;
        }
    }

    /**
     * æ¥å—æ‰€æœ‰ä¿®æ”¹
     */
    private async acceptAllBlocks(filePath: string): Promise<void> {
        this.logService.warn(`âœ… [AcceptAll] æ¥å—æ‰€æœ‰ä¿®æ”¹`);

        this.isApplyingChange = true;
        try {
            const doc = await vscode.workspace.openTextDocument(vscode.Uri.file(filePath));
            const blocks = this.codeLensProvider.parseConflictBlocks(doc);

            if (blocks.length === 0) {
                return;
            }

            const lines = doc.getText().split('\n');
            const newLines: string[] = [];
            let lastLine = 0;

            for (const block of blocks) {
                // æ·»åŠ æœªä¿®æ”¹çš„è¡Œ
                newLines.push(...lines.slice(lastLine, block.startLine));
                // æ·»åŠ æ–°å†…å®¹ï¼ˆè·³è¿‡æ—§å†…å®¹å’Œæ ‡è®°ï¼‰
                newLines.push(...lines.slice(block.separatorLine + 1, block.endLine));
                lastLine = block.endLine + 1;
            }

            // æ·»åŠ å‰©ä½™è¡Œ
            newLines.push(...lines.slice(lastLine));

            const edit = new vscode.WorkspaceEdit();
            const fullRange = new vscode.Range(
                doc.positionAt(0),
                doc.positionAt(doc.getText().length)
            );
            edit.replace(doc.uri, fullRange, newLines.join('\n'));
            await vscode.workspace.applyEdit(edit);

            // æ›´æ–°ç¼“å­˜
            this.documentContentCache.set(filePath, newLines.join('\n'));

            // æ¸…é™¤è£…é¥°
            const editor = vscode.window.visibleTextEditors.find(e => e.document.uri.fsPath === filePath);
            if (editor) {
                this.updateDecorations(editor);
            }
            this.codeLensProvider.refresh();

            // æ¸…ç†ç¼“å­˜å¹¶ä¿å­˜æ–‡ä»¶
            this.originalContentCache.delete(filePath);
            await doc.save();
            vscode.window.setStatusBarMessage(`âœ… å·²æ¥å—æ‰€æœ‰ä¿®æ”¹`, 5000);
        } finally {
            this.isApplyingChange = false;
        }
    }

    /**
     * æ‹’ç»æ‰€æœ‰ä¿®æ”¹
     */
    private async rejectAllBlocks(filePath: string): Promise<void> {
        this.logService.warn(`âŒ [RejectAll] æ‹’ç»æ‰€æœ‰ä¿®æ”¹`);

        this.isApplyingChange = true;
        try {
            const doc = await vscode.workspace.openTextDocument(vscode.Uri.file(filePath));
            const blocks = this.codeLensProvider.parseConflictBlocks(doc);

            if (blocks.length === 0) {
                return;
            }

            const lines = doc.getText().split('\n');
            const newLines: string[] = [];
            let lastLine = 0;

            for (const block of blocks) {
                // æ·»åŠ æœªä¿®æ”¹çš„è¡Œ
                newLines.push(...lines.slice(lastLine, block.startLine));
                // æ·»åŠ æ—§å†…å®¹ï¼ˆè·³è¿‡æ–°å†…å®¹å’Œæ ‡è®°ï¼‰
                newLines.push(...lines.slice(block.startLine + 1, block.separatorLine));
                lastLine = block.endLine + 1;
            }

            // æ·»åŠ å‰©ä½™è¡Œ
            newLines.push(...lines.slice(lastLine));

            const edit = new vscode.WorkspaceEdit();
            const fullRange = new vscode.Range(
                doc.positionAt(0),
                doc.positionAt(doc.getText().length)
            );
            edit.replace(doc.uri, fullRange, newLines.join('\n'));
            await vscode.workspace.applyEdit(edit);

            // æ›´æ–°ç¼“å­˜
            this.documentContentCache.set(filePath, newLines.join('\n'));

            // æ¸…é™¤è£…é¥°
            const editor = vscode.window.visibleTextEditors.find(e => e.document.uri.fsPath === filePath);
            if (editor) {
                this.updateDecorations(editor);
            }
            this.codeLensProvider.refresh();

            // æ¸…ç†ç¼“å­˜å¹¶ä¿å­˜æ–‡ä»¶
            this.originalContentCache.delete(filePath);
            await doc.save();
            vscode.window.setStatusBarMessage(`âŒ å·²æ‹’ç»æ‰€æœ‰ä¿®æ”¹`, 5000);
        } finally {
            this.isApplyingChange = false;
        }
    }

    /**
     * æ¸…ç†èµ„æº
     */
    dispose(): void {
        this.disposables.forEach(d => d.dispose());
        // ===== ä»¥ä¸‹è£…é¥°å™¨æ¸…ç†å·²æ³¨é‡Š =====
        // this.conflictStartDecoration?.dispose();
        // this.originalContentDecoration?.dispose();
        // this.separatorDecoration?.dispose();
        // this.modifiedContentDecoration?.dispose();
        // this.conflictEndDecoration?.dispose();
    }
}
